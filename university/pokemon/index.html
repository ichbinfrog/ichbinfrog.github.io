<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Ce travail a Ã©tÃ© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&amp;rsquo;UV SY09.
  Issu d&amp;rsquo;une franchise de jeu vidÃ©o japonaise, un pokÃ©mon est une crÃ©ature qui, une fois capturÃ©e par un dresseur, peut-Ãªtre envoyÃ© pour affronter les pokÃ©mon d&amp;rsquo;un autre dresseur. RÃ©gi par un ensemble de rÃ¨gles bien dÃ©finies, la complexitÃ© des combats qui en dÃ©rive et les modÃ¨les qui les prÃ©disent constituent l&amp;rsquo;intÃ©rÃªt de cette Ã©tude." />
<meta name="keywords" content=", ml, pokemon, svm, knn, decision tree, random forest, adaboost" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://ichbinfrog.github.io/university/pokemon/" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: { autoNumber: "AMS" },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(), i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({
        
        TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
</script>


    <title>
        
            ðŸ‡«ðŸ‡· Pokemon victory prediction :: Hoang Quoc Trung 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.cbd9ce6c3a26d6c4a5eb4b8834c18d83518654bd8bac1fc8160486f336181c9a.css">


    
        <link rel="stylesheet" type="text/css" href="/css/post.css">
    





<meta itemprop="name" content="ðŸ‡«ðŸ‡· Pokemon victory prediction">
<meta itemprop="description" content="Ce travail a Ã©tÃ© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&rsquo;UV SY09.
  Issu d&rsquo;une franchise de jeu vidÃ©o japonaise, un pokÃ©mon est une crÃ©ature qui, une fois capturÃ©e par un dresseur, peut-Ãªtre envoyÃ© pour affronter les pokÃ©mon d&rsquo;un autre dresseur. RÃ©gi par un ensemble de rÃ¨gles bien dÃ©finies, la complexitÃ© des combats qui en dÃ©rive et les modÃ¨les qui les prÃ©disent constituent l&rsquo;intÃ©rÃªt de cette Ã©tude.">
<meta itemprop="datePublished" content="2020-06-30T11:55:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-06-30T11:55:00&#43;00:00" />
<meta itemprop="wordCount" content="4110">
<meta itemprop="image" content="https://ichbinfrog.github.io/"/>



<meta itemprop="keywords" content="ml,pokemon,svm,knn,decision tree,random forest,adaboost," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ichbinfrog.github.io/"/>

<meta name="twitter:title" content="ðŸ‡«ðŸ‡· Pokemon victory prediction"/>
<meta name="twitter:description" content="Ce travail a Ã©tÃ© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&rsquo;UV SY09.
  Issu d&rsquo;une franchise de jeu vidÃ©o japonaise, un pokÃ©mon est une crÃ©ature qui, une fois capturÃ©e par un dresseur, peut-Ãªtre envoyÃ© pour affronter les pokÃ©mon d&rsquo;un autre dresseur. RÃ©gi par un ensemble de rÃ¨gles bien dÃ©finies, la complexitÃ© des combats qui en dÃ©rive et les modÃ¨les qui les prÃ©disent constituent l&rsquo;intÃ©rÃªt de cette Ã©tude."/>



    <meta property="og:title" content="ðŸ‡«ðŸ‡· Pokemon victory prediction" />
<meta property="og:description" content="Ce travail a Ã©tÃ© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&rsquo;UV SY09.
  Issu d&rsquo;une franchise de jeu vidÃ©o japonaise, un pokÃ©mon est une crÃ©ature qui, une fois capturÃ©e par un dresseur, peut-Ãªtre envoyÃ© pour affronter les pokÃ©mon d&rsquo;un autre dresseur. RÃ©gi par un ensemble de rÃ¨gles bien dÃ©finies, la complexitÃ© des combats qui en dÃ©rive et les modÃ¨les qui les prÃ©disent constituent l&rsquo;intÃ©rÃªt de cette Ã©tude." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ichbinfrog.github.io/university/pokemon/" />
<meta property="og:image" content="https://ichbinfrog.github.io/"/>
<meta property="article:published_time" content="2020-06-30T11:55:00+00:00" />
<meta property="article:modified_time" content="2020-06-30T11:55:00+00:00" /><meta property="og:site_name" content="Hoang Quoc Trung" />






    <meta property="article:published_time" content="2020-06-30 11:55:00 &#43;0000 UTC" />








    </head>

    <body class="">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">ichbinfrog</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://ichbinfrog.github.io/projects">0_projects</a></li><li><a href="https://ichbinfrog.github.io/internships">1_internships</a></li><li><a href="https://ichbinfrog.github.io/university">2_uni_works</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title" id="top"><a href="https://ichbinfrog.github.io/university/pokemon/">ðŸ‡«ðŸ‡· Pokemon victory prediction</a></h2>
            <aside id="toc"><style>
.toc {
    position: fixed;
    top: 50%;
    left: 2%;
    width: 20%;
    transform: translateY(-50%);
    border-radius: 5px;
    padding-bottom: 1rem;
}

.toc a {
    text-decoration: none;
    color: gray;
}

.toc a:hover {
    opacity: 0.5;
}

.toc ul {
    list-style: ">  ";
}

.toc-title {
    text-decoration: underline;
}
</style>

<div class="toc">
    <div class="toc-title">Table of Contents</div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#analyse-exploratoire">Analyse exploratoire</a>
      <ul>
        <li><a href="#caractÃ©ristiques-dun-pokÃ©mon">CaractÃ©ristiques d&rsquo;un pokÃ©mon</a></li>
        <li><a href="#combats">Combats</a></li>
        <li><a href="#problÃ©matique">ProblÃ©matique</a></li>
      </ul>
    </li>
    <li><a href="#enrichissement-du-jeu-de-donnÃ©es">Enrichissement du jeu de donnÃ©es</a>
      <ul>
        <li><a href="#introduction-dune-hiÃ©rarchie">Introduction d&rsquo;une hiÃ©rarchie</a></li>
      </ul>
    </li>
    <li><a href="#rÃ©duction-des-dimensions">RÃ©duction des dimensions</a>
      <ul>
        <li><a href="#analyse-en-composantes-principales">Analyse en composantes principales</a></li>
        <li><a href="#matrice-de-distance-intermÃ©diaire">Matrice de distance intermÃ©diaire</a></li>
      </ul>
    </li>
    <li><a href="#k-plus-proches-voisins-knn">K Plus Proches Voisins (KNN)</a>
      <ul>
        <li><a href="#principe">Principe</a></li>
        <li><a href="#application">Application</a></li>
      </ul>
    </li>
    <li><a href="#support-vector-machine-svm">Support Vector Machine (SVM)</a>
      <ul>
        <li><a href="#principe-1">Principe</a></li>
        <li><a href="#application-1">Application</a></li>
      </ul>
    </li>
    <li><a href="#arbre-de-dÃ©cision">Arbre de dÃ©cision</a>
      <ul>
        <li><a href="#principe-2">Principe</a></li>
        <li><a href="#rÃ©gularisation">RÃ©gularisation</a></li>
        <li><a href="#application-2">Application</a></li>
      </ul>
    </li>
    <li><a href="#forÃªt-alÃ©atoire">ForÃªt alÃ©atoire</a>
      <ul>
        <li><a href="#principe-3">Principe</a></li>
        <li><a href="#application-3">Application</a></li>
      </ul>
    </li>
    <li><a href="#adaptative-boosting">Adaptative Boosting</a>
      <ul>
        <li><a href="#principe-4">Principe</a></li>
        <li><a href="#application-4">Application</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a>
      <ul>
        <li><a href="#Ã©valuation-des-performances">Ã‰valuation des performances</a></li>
        <li><a href="#conclusions-et-futurs-travaux">Conclusions et futurs travaux</a></li>
      </ul>
    </li>
  </ul>
</nav>
    <ul>
    <li><a href="#top">Top</a></li>
    <li><a href="#end">End</a></li>
    </ul>
</div></aside>

            

            <div class="post-content">
                <blockquote>
<p>Ce travail a Ã©tÃ© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&rsquo;UV SY09.</p>
</blockquote>
<blockquote>
<p>Issu d&rsquo;une franchise de jeu vidÃ©o japonaise, un pokÃ©mon est une crÃ©ature qui, une fois capturÃ©e par un dresseur, peut-Ãªtre envoyÃ© pour affronter les pokÃ©mon d&rsquo;un autre dresseur. RÃ©gi par un ensemble de rÃ¨gles bien dÃ©finies, la complexitÃ© des combats qui en dÃ©rive et les modÃ¨les qui les prÃ©disent constituent l&rsquo;intÃ©rÃªt de cette Ã©tude.</p>
</blockquote>
<h2 id="analyse-exploratoire">Analyse exploratoire</h2>
<p>Cette collection, provenant de <a href="https://www.kaggle.com/terminus7/pokemon-challenge%22">Kaggle</a>, est constituÃ©e de trois jeu de donnÃ©es diffÃ©rents;</p>
<h3 id="caractÃ©ristiques-dun-pokÃ©mon">CaractÃ©ristiques d&rsquo;un pokÃ©mon</h3>
<p>Ce jeu de donnÃ©es prÃ©sente les caractÃ©ristiques de 800 pokÃ©mon extraites directement du code objet du jeu. Chaque pokÃ©mon, identifiÃ© de maniÃ¨re unique par un nom ou un entier, se caractÃ©rise par un boolÃ©en qui indique s&rsquo;il est <strong>lÃ©gendaire</strong> ainsi que par sa <strong>gÃ©nÃ©ration</strong> (&ldquo;version&rdquo; Ã  partir de laquelle le pokÃ©mon a Ã©tÃ© ajoutÃ©). Un pokÃ©mon est aussi caractÃ©risÃ© par ses statistiques;</p>
<ul>
<li><strong>speed</strong>: dÃ©termine s&rsquo;il prend l&rsquo;initiative lors d&rsquo;un combat</li>
<li><strong>hp</strong>: nombre de point de dommages qu&rsquo;il peut subir avant d&rsquo;Ãªtre Ã©liminÃ©</li>
<li><strong>attack</strong>: puissance de ses attaques physiques</li>
<li><strong>defense</strong>: rÃ©sistance aux attaques physiques</li>
<li><strong>sp. attack</strong>: puissance des attaques &ldquo;magiques&rdquo; (le pokemon ne touche physiquement pas son adversaire mais inflige tout de mÃªme des dÃ©gÃ¢ts)</li>
<li><strong>sp. defense</strong>: rÃ©sistance aux attaques spÃ©ciales</li>
</ul>
<p>Normalement, les statistiques d&rsquo;un pokÃ©mon sont basÃ©es sur des statistiques de base augmentent lorsque le pokÃ©mon monte en niveau, mais cette dimension n&rsquo;est pas considÃ©rÃ©e dans ce jeu de donnÃ©es. De plus, chaque pokÃ©mon appartient Ã  un ou deux <strong>types</strong> (e.g. Feu, Eau, Acier, Ã‰lectricitÃ©, Vol&hellip;) qui indique quelles capacitÃ©s peuvent Ãªtre apprises et ses forces/faiblesses par rapport Ã  des pokÃ©mon d&rsquo;autres types (e.g. les pokemon de type Feu sont plus vulnÃ©rables aux attaques de type Eau, mais plus rÃ©sistants aux attaques de type Plante).</p>
<h3 id="combats">Combats</h3>
<p>Ce tableau prÃ©sente les codes des belligÃ©rants de 50001 duels et le vainqueur. Ces triplets synthÃ©tiques sont gÃ©nÃ©rÃ©s par un algorithme qui simplifie certains aspects du jeu notamment les capacitÃ©s. En rÃ©alitÃ©, un combat se dÃ©roule selon les rÃ¨gles suivantes:</p>
<ul>
<li>Le pokÃ©mon prÃ©sent dans la premiÃ¨re colonne dispose de l&rsquo;initiative pour le premier tour.</li>
<li>Ã€ chaque tour, chaque pokÃ©mon choisit et utilise une de ses quatre capacitÃ©s (une attaque physique ou spÃ©ciale, une attaque de modification de statistiques, etc) jusqu&rsquo;Ã  ce que les points de vie de l&rsquo;un des deux tombe Ã  0 et la victoire est alors accordÃ©e Ã  l&rsquo;autre.</li>
</ul>
<p>Afin d&rsquo;allÃ©ger la notation, notons dorÃ©navant $\Omega$ (l&rsquo;ensemble des pokÃ©mon) et donc $\Omega^2$ (l&rsquo;ensemble des statistiques de deux pokÃ©mon qui s&rsquo;affrontent en duel).</p>
<p>En interpolant Ã  partir des donnÃ©es sur les combats, on peut Ã©mettre l&rsquo;hypothÃ¨se que le rÃ©sultat d&rsquo;un combat entre deux pokÃ©mons est <strong>dÃ©terministe</strong> car:</p>
<ul>
<li>Il n&rsquo;y a pas de combats oÃ¹ un pokÃ©mon affronte l&rsquo;exact mÃªme pokÃ©mon. Si ce cas de figure existe, les deux belligÃ©rants auraient exactement les mÃªmes statistiques de combats et le rÃ©sultat devrait donc Ãªtre soit dÃ©cidÃ© de maniÃ¨re alÃ©atoire soit une <em>Ã©galitÃ©</em>.</li>
<li>Il n&rsquo;y a pas deux combats entre $p_1$ et $p_2$ oÃ¹ dans l&rsquo;un $p_1$ attaque en premier et dans l&rsquo;autre il attaque en deuxiÃ¨me.</li>
<li>Chaque combat a un gagnant unique.</li>
</ul>
<p>Il est donc possible de construire un classifieur binaire pour prÃ©dire le rÃ©sultat d&rsquo;un combat oÃ¹ $True$ correspond Ã  la victoire du premier pokÃ©mon qui attaque et $False$ sinon. NÃ©anmoins, seulement $14.409%$ des combinaisons de paires possibles de pokÃ©mon sont reprÃ©sentÃ©es donc notre modÃ¨le sera entraÃ®nÃ© sur une partie relativement petite de l&rsquo;ensemble $\Omega^2$. Un Ã©chantillon de test accompagne aussi la table des combats. Tout de mÃªme, celui-ci est inutile pour vÃ©rifier la validitÃ© du modÃ¨le car il ne prÃ©sente pas le code du vainqueur.</p>
<h3 id="problÃ©matique">ProblÃ©matique</h3>
<p>Le but ce cette Ã©tude est donc d&rsquo;appliquer un large Ã©ventail d&rsquo;algorithmes d&rsquo;apprentissage supervisÃ©s et non supervisÃ©s afin de construire un modÃ¨le, qui, prend en entrÃ©e deux pokÃ©mon et prÃ©dit le gagnant.</p>
<hr>
<h2 id="enrichissement-du-jeu-de-donnÃ©es">Enrichissement du jeu de donnÃ©es</h2>
<h3 id="introduction-dune-hiÃ©rarchie">Introduction d&rsquo;une hiÃ©rarchie</h3>
<p>Un pokÃ©mon dispose parfois d&rsquo;une chaÃ®ne d&rsquo;Ã©volution (e.g. SalamÃ¨che $\rightarrow$ Reptincel $\rightarrow$ Dracaufeu), les pokÃ©mon en fin de chaÃ®ne Ã©tant en gÃ©nÃ©ral plus puissants que ceux en dÃ©but. Afin de tester si cette catÃ©gorisation hiÃ©rarchique contribue Ã  la amÃ©liorer la classification, nous avons introduit le stage d&rsquo;Ã©volution d&rsquo;un pokemon (0 Ã©tant l&rsquo;Ã©tat en dÃ©but de chaÃ®ne d&rsquo;Ã©volution qui incrÃ©mente de 1 jusqu&rsquo;Ã  ce qu&rsquo;on atteint un pokÃ©mon en fin de chaÃ®ne) grÃ¢ce Ã  <a href="https://pokeapi.co/">PokeAPI</a>.</p>
<p><strong>Ajout d&rsquo;une mÃ©trique</strong></p>
<p>Afin de combiner le jeu de donnÃ©es des pokÃ©mon et des combats, il est possible de comprimer le tableau de combats en une seule mÃ©trique, le taux de victoire avec la formule:</p>
<p>$$win\_rate(p_i) = \frac{nombre\_de\_victoires(p_i)}{nombre\_de\_combats(p_i)}$$</p>
<p><p style="text-align:center; font-style: italic; padding-bottom: 15px;">Matrice des corrÃ©lations des caractÃ©ristiques des pokÃ©mon</p>

<img src="/img/pokemon_heatmap.png"  class="center"  />

</p>
<p>La matrice de corrÃ©lation issue du jeu de donnÃ©e enrichi dÃ©montre une corrÃ©lation forte entre la vitesse d&rsquo;un pokÃ©mon et son taux de victoire ainsi que le niveau d&rsquo;Ã©volution et la gÃ©nÃ©ration. La deuxiÃ¨me relation s&rsquo;explique par l&rsquo;introduction des chaÃ®nes d&rsquo;Ã©volutions plus longues au fur et Ã  mesure de la parution de nouveaux jeux PokÃ©mon (e.g. Ã©volutions mÃ©ga, X ou Y).</p>
<p>Il est tout de mÃªme surprenant que les attributs de dÃ©fenses (hp, defense, sp. defense) affectent trÃ¨s peu le taux de victoire du pokÃ©mon. Au contraire, les attributs offensifs (speed, attack, sp. attack) sont plus fortement corrÃ©lÃ©s Ã  la probabilitÃ© de gagner un duel.</p>
<p>
<img src="/img/pokemon_reg.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">RegrÃ©ssion des attributs les plus fortement corrÃ©lÃ©s au taux de victoire</p></p>
<p>De mÃªme, le jeu de donnÃ©es des combats peut Ãªtre enrichi en ajoutant les caractÃ©ristiques de chaque participants. Tout de mÃªme, le tableau individu-variable de taille importante ($50001$ lignes et $21$ colonnes) qui en rÃ©sulte ralentit l&rsquo;entraÃ®nement des algorithmes et augmente la quantitÃ© de ressource consommÃ©e. Il sera donc nÃ©cessaire de rÃ©duire ses dimensions via des algorithmes linÃ©aires (PCA) linÃ©aire ou en agrÃ©geant les attributs en des mÃ©triques plus consÃ©quentes.</p>
<p>Au lieu de considÃ©rer les attributs attaque/attaque spÃ©ciale et dÃ©fense/dÃ©fense spÃ©ciale, il est aussi possible d&rsquo;additionner les deux statistiques pour en former une statistique <em>attaque</em> et <em>dÃ©fense</em> plus gÃ©nÃ©rale (ce jeu de donnÃ©e s&rsquo;appellera dÃ©sormais <em>reduced_diff</em>).</p>
<p><strong>Impact des types</strong></p>
<p>Afin d&rsquo;Ã©tudier l&rsquo;impact des mÃ©canismes de faiblesse par rapport aux types des deux combattants sur l&rsquo;issue du duel, deux attributs ont Ã©tÃ© ajoutÃ©s, le multiplicateur de puissance d&rsquo;attaque de chacun des pokÃ©mon. Ces derniÃ¨res rÃ©duisent quatre valeurs qualitatives (catÃ©gorie) en deux valeurs quantitatives grÃ¢ce Ã  la formule:</p>
<p>$$\tau_{type_1(p_1),type_1(p_2)} \times \tau_{type_1(p_1),type_2(p_2)}$$</p>
<p>$$\tau_{type_2(p_1),type_1(p_2)} \times \tau_{type_2(p_1),type_2(p_2))}$$</p>
<p>Avec $\tau$ la matrice des multiplicateurs de la puissance d&rsquo;attaque de la VIIÃ¨me gÃ©nÃ©ration, avec $\tau_{t_1,t_2} \in \mathbb{R}^+$ le multiplicateur d&rsquo;attaquant de type $t_1$ par rapport Ã  un dÃ©fendant de type $t_2$. Afin d&rsquo;obtenir le multiplicateur dans le sens inverse, il suffit de prendre $mult(p_2, p_1)$.</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">victoire du 1er pokÃ©mon</th>
<th align="center">victoire du 2nd pokÃ©mon</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">mult(p1,p2)&gt; mult(p2,p1)</td>
<td align="center">0.51346</td>
<td align="center">0.48654</td>
</tr>
<tr>
<td align="center">mult(p1,p2)=mult(p2,p1)</td>
<td align="center">0.481212</td>
<td align="center">0.518788</td>
</tr>
<tr>
<td align="center">mult(p1,p2)&lt; mult(p2,p1)</td>
<td align="center">0.415805</td>
<td align="center">0.584195</td>
</tr>
<tr>
<td align="center">total</td>
<td align="center">0.47202</td>
<td align="center">0.52798</td>
</tr>
</tbody>
</table>
<p>La matrice de contingence relative entre ses multiplicateurs et l&rsquo;issue du combat, rÃ©vÃ¨le une inclinaison positive vers la victoire du $2^{nd}$ pokÃ©mon ainsi qu&rsquo;une absence de corrÃ©lation claire entre l&rsquo;avantage que confÃ¨re le type et la victoire.</p>
<hr>
<h2 id="rÃ©duction-des-dimensions">RÃ©duction des dimensions</h2>
<h3 id="analyse-en-composantes-principales">Analyse en composantes principales</h3>
<p>Pour le jeu de donnÃ©es des combats, la colonne <em>vainqueur</em> pose problÃ¨me puisqu&rsquo;elle est logiquement fortement corrÃ©lÃ©e Ã  <em>first_pokemon</em> et <em>second_pokemon</em> et difficilement manipulable. La conversion de l&rsquo;attribut <em>vainqueur</em> en un boolÃ©en qui reprÃ©sente si le vainqueur correspond bien au premier pokÃ©mon, donne un domaine $\Omega^2 \times {True, False}$ plus facile Ã  manipuler.</p>
<p>DÃ¨s lors, l&rsquo;application d&rsquo;une ACP s&rsquo;avÃ¨re utile Ã  cause du flÃ©au de la dimension en permettant de projeter l&rsquo;espace prÃ©cÃ©dente dans un espace $\mathbb{R}^n$ avec $n$ le nombre d&rsquo;axes factoriels. Les contributions relatives des axes d&rsquo;une ACP avec l&rsquo;ensemble du tableau rÃ©vÃ¨lent un coude au niveau du deuxiÃ¨me axe factoriel. NÃ©anmoins, mÃªme si les premiers et deuxiÃ¨mes axes expliquent $91.36%$ de l&rsquo;inertie totale, l&rsquo;introduction d&rsquo;un troisiÃ¨me axe donne une structure nettement sÃ©parÃ©e entre les classes au lieu des classes confondues (axe1-axe3).</p>
<p>
<img src="/img/pokemon_battles_pca.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">ACP des combats Ã  trois axes factoriels.</p></p>
<h3 id="matrice-de-distance-intermÃ©diaire">Matrice de distance intermÃ©diaire</h3>
<p>Il est possible de rÃ©duire l&rsquo;espace sans une ACP en soustrayant les statistiques des combattants. Certaines des diffÃ©rences obtenues corrÃ¨lent fortement Ã  l&rsquo;issue du duel. La combinaison de ces diffÃ©rences peut donc rÃ©vÃ©ler une fonction de distance $d:\Omega^2 \mapsto \mathbb{R}$ et une fonction de rÃ©gression $r: \mathbb{R} \mapsto {True, False}$ qui donne en combinaison la classification voulue : $clf = r \circ d$.</p>
<p>Tout de mÃªme, la table des combats contient des variables qui ne permet pas Ã  l&rsquo;Ã©valuation. Les variables qualitatives comme le type des pokÃ©mon sont transformÃ©es par la formule des types. Les attributs boolÃ©ennes peuvent Ãªtre convertis en $0(False), 1(True)$ puis une soustrait. NÃ©anmoins, puisque cette conversion nuÃ®t Ã  l&rsquo;interprÃ©tabilitÃ© du modÃ¨le, les variables boolÃ©ennes sont alors Ã©liminÃ©es.</p>

<img src="/img/pokemon_battles_heatmap.png"  class="center"  />


<p>Pour les autres statistiques de combats et les taux de victoires, une diffÃ©rence absolue est utilisÃ©e afin de respecter la symÃ©trie de la distance. Il est possible d&rsquo;utiliser la diffÃ©rence exacte de la diffÃ©rence des taux de victoires mais celle-ci nÃ©cessite que l&rsquo;ensemble des anciens adversaires soient relativement consÃ©quentes. Or, la matrice des combats est creuse ($14%$ de remplissage).</p>
<p>$$\frac{|V(p_1) \cap Adv(p_1,p_2)| - |V(p_2)\cap Adv(p_1,p_2)|}{|Adv(p_1,p_2)|}$$</p>
<p>$$V(p_1) = vaincus, par, p_1$$</p>
<p>$$Adv(p_1) = adversaires, de, p_1$$</p>
<p>$$Adv(p_1,p_2) = Adv(p_1) \cap Adv(p_2)$$</p>
<p>De plus, il est possible de rÃ©duire d&rsquo;autant plus la dimension en effectuant une ACP sur ces diffÃ©rences. La mÃ©thode du coude rÃ©vÃ¨le que 6 axes factoriels expliquent la majoritÃ© de la variance expliquÃ©e.</p>
<hr>
<h2 id="k-plus-proches-voisins-knn">K Plus Proches Voisins (KNN)</h2>
<h3 id="principe">Principe</h3>
<p>L&rsquo;algorithme des KNN est une mÃ©thode de classification supervisÃ©e qui ne nÃ©cessite pas d&rsquo;apprentissage. Lorsque l&rsquo;on souhaite classer une nouvelle donnÃ©e, on relÃ¨ve les K plus proches voisins (en termes d&rsquo;attributs) parmi le jeu de donnÃ©es existant et on classe cette nouvelle donnÃ©e dans la classe prÃ©dominante parmi les K plus proches voisins qui l&rsquo;entourent.</p>
<h3 id="application">Application</h3>
<p>En faisant varier le nombre de dimensions de la PCA, on observe que la performance de l&rsquo;algorithme sur le dataset des diffÃ©rences est optimale Ã  6 axes factoriels. De plus, la rÃ©duction de la dimension semble diminuer le nombre de voisins Ã  partir duquel les KNNs convergent vers la qualitÃ© de prÃ©diction optimale.</p>
<p>
<img src="/img/pokemon_knn_battles_difference_df.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Validation croisÃ©e Ã  5 coupes des KNN en fonction du nombre K de voisins et de la dimension de l&#39;ACP</p></p>
<p>Au-delÃ  d&rsquo;un certain seuil de voisins, la croissance en terme de qualitÃ© de prÃ©diction est nÃ©gligeable et ne justifie pas le coÃ»t algorithmique supplÃ©mentaire. Pour notre jeu de donnÃ©es, ce seuil se trouve aux alentours de 20 voisins et donne un accuracy_score de $91%$. De mÃªme, l&rsquo;application sur <em>reduced_diff</em> donne les mÃªmes observations mais avec une prÃ©cision lÃ©gÃ¨rement amÃ©liorÃ©e.</p>
<p>Par dÃ©faut, l&rsquo;implÃ©mentation KNN de sklearn utilise une distance euclidienne pour trouver les voisins les plus proches et chaque individu est pondÃ©rÃ© de maniÃ¨re uniforme. Le choix de la distance dÃ©termine en pratique la forme du volume de dimension $N$ qui dÃ©limite les frontiÃ¨res d&rsquo;un point;</p>
<ul>
<li><em>euclidien</em> ($\sqrt{\Sigma(x - y)^2}$) : sphÃ¨re de $N$ dimensions.</li>
<li><em>manhattan</em> ($\Sigma(|x - y|)$) : cube de $N$ dimensions</li>
<li><em>chebyshev</em> ($max(|x - y|)$) : cube de $N$ dimensions oÃ¹ la longueur correspond Ã  la distance maximale d&rsquo;un attribut entre deux individus donnÃ©s.</li>
</ul>
<p>La distance de <em>manhattan</em> aurait donc tendance de considÃ©rer plus d&rsquo;individus comme voisins que par rapport aux autres. En appliquant sur le jeu de donnÃ©es, on observe que l&rsquo;utilisation de cette manhattan donne le meilleur estimateur parmi les autres distances. Une piste d&rsquo;amÃ©lioration serait alors d&rsquo;Ã©tudier l&rsquo;effet des distances qui engendrent des volumes plus important (par exemple les distances de <em>minkowski</em> avec $p \in ]0,1[$).</p>
<p>
<img src="/img/pokemon_knn_dist.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">QualitÃ© du modÃ¨le KNN selon la distance et la pondÃ©ration des individus aprÃ¨s validation croisÃ©e Ã  5 coupes</p></p>
<p>De mÃªme, la qualitÃ© du modÃ¨le issu de la distance de manhattan suggÃ¨re qu&rsquo;il n&rsquo;est pas sur-apprenti (l&rsquo;inclusion de plus de points l&rsquo;amÃ©liore). On peut donc renforcer l&rsquo;effet de la distance dans l&rsquo;algorithme en donnant chaque individu un poids qui correspond Ã  l&rsquo;inverse de sa distance Ã  l&rsquo;Ã©lÃ©ment Ã  classifier (option <em>distance</em> sur sklearn). Cette modification amÃ©liore un tout petit peu la qualitÃ© et confirme l&rsquo;hypothÃ¨se prÃ©cÃ©dente.</p>
<hr>
<h2 id="support-vector-machine-svm">Support Vector Machine (SVM)</h2>
<h3 id="principe-1">Principe</h3>
<p>Les machines Ã  vecteurs de support (Support Vector Machine) ont pour but de sÃ©parer les donnÃ©es en classes Ã  lâ€™aide dâ€™une frontiÃ¨re aussi simple que possible, de telle faÃ§on que la distance entre les diffÃ©rents groupes de donnÃ©es et la frontiÃ¨re qui les sÃ©pare soit maximale. Cette distance est aussi appelÃ©e <strong>marge</strong> et les donnÃ©es les plus proches de la frontiÃ¨re sont appelÃ©es les <strong>vecteurs de support</strong>.</p>
<p>
<img src="/img/pokemon_svm.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Illustration d&#39;un SVM avec la frontiÃ¨re (droite noire), les vecteurs de support (points entourÃ©s) et les marge (droites bleue et rouge)</p></p>
<p>Pour un problÃ¨me de classification binaire, la frontiÃ¨re de dÃ©cision est un hyperplan dÃ©fini par;
$$h(x)=w^{T}x+b = 0$$</p>
<p>$x$ les donnÃ©es d&rsquo;entrÃ©e de dimension $N$, $w$ le vecteur des poids et $b$ la distance entre l&rsquo;hyperplan et l&rsquo;origine. Trouver l&rsquo;hyperplan de marge maximale revient donc Ã :</p>
<p>$$\frac  {1}{2}||w||^{2}, \quad \quad l_{k}(w^{T}x_{k}+w_{0})\geq 1$$</p>
<p>avec ${\displaystyle l_{k}}$ le label du vecteur $x_k$, ${\displaystyle l_{k}} \subset {\displaystyle {-1,1}}$.  Ceci peut se rÃ©soudre par la mÃ©thode classique des multiplicateurs de Lagrange, avec le lagrangien:</p>
<p>$$L(w,b,\alpha)=\frac {1}{2}||w||^{2}-\sum_{k=1}^{p}\alpha_{k}(l_{k}(w^{T}x_{k}+b)-1)$$</p>
<p>Le lagrangien doit Ãªtre minimisÃ© par rapport Ã  w et b, et maximisÃ© par rapport Ã  $\alpha$. AprÃ¨s avoir rÃ©solu $\alpha$, on trouve w et b pour obtenir le modÃ¨le:</p>
<p>$$h(x)=\sum_{k=1}^{p}\alpha_{k}^{*}l_{k}(x\cdot x_{k})+b$$</p>
<p>Pour les problÃ¨mes sÃ©parables non linÃ©aires dans l&rsquo;espace d&rsquo;origine, l&rsquo;Ã©chantillon peut Ãªtre mappÃ© de l&rsquo;espace d&rsquo;origine vers un espace d&rsquo;entitÃ©s de dimension supÃ©rieure, de sorte que l&rsquo;Ã©chantillon est sÃ©parable linÃ©airement dans cet espace d&rsquo;entitÃ©s grÃ¢ce Ã  une fonction de noyau (<strong>kernel</strong>).</p>
<h3 id="application-1">Application</h3>
<p>La clÃ© de l&rsquo;application d&rsquo;une SVM rÃ©side dans la sÃ©lection des fonctions du noyau. Les fonctions de noyau doivent correspondre Ã  un produit scalaire et les plus couramment utilisÃ©es comprennent:
\begin{itemize}</p>
<ul>
<li>
<p><strong>noyau linÃ©aire</strong> : sans changement d&rsquo;espace, on se ramÃ¨ne Ã  une classification linÃ©aire.</p>
</li>
<li>
<p><strong>noyau polynomial</strong> :
$K(u,v) = (coef0 + \langle u, v\rangle)^d$ avec $d$ le degrÃ© du polynÃ´me; un degrÃ© de $1$ revient Ã  faire un noyau linÃ©aire et Ã  des degrÃ©s trop grand, le modÃ¨le risque de sur-apprendre.</p>
</li>
<li>
<p><strong>fonction de base radiale</strong> :
$K(u,v) = exp(-\gamma \times\Vert u, v\Vert)$. Cette fonction donne en gÃ©nÃ©rale des bons rÃ©sultats pour des sÃ©parations non linÃ©aires.</p>
</li>
<li>
<p><strong>noyau sigmoÃ¯de</strong>:
$K(u,v) = tanh(\gamma \times\Vert u, v\Vert + coef0)$</p>
</li>
</ul>
<p>La Figure suivante permet de visualiser la diffÃ©rence des marges et de la frontiÃ¨re entre les noyaux. Tout de mÃªme, il n&rsquo;est pas possible de visualiser les donnÃ©es Ã  dimension $&gt; 2$ et donc d&rsquo;estimer quel kernel est le mieux adaptÃ©.</p>
<p>
<img src="/img/pokemon_svm_kernel.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Comparaison de la frontiÃ¨re des diffÃ©rentes kernel sur une PCA Ã  deux dimensions des diffÃ©rences des pokÃ©mons</p></p>
<p>En testant tout les kernels de base dans la librairie de sklearn, l&rsquo;utilisation d&rsquo;un kernel RBF donne en moyenne un meilleur estimateur ainsi que le temps d&rsquo;entraÃ®nement le plus rapide pour notre jeu de donnÃ©es.</p>
<table>
<thead>
<tr>
<th align="center">kernel</th>
<th align="center">accuracy score moyenne (cv 5)</th>
<th align="center">temps dâ€™entraÃ®nement moyen (en s)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">linear</td>
<td align="center">0.899007</td>
<td align="center">3981</td>
</tr>
<tr>
<td align="center">poly</td>
<td align="center">0.864955</td>
<td align="center">20.998</td>
</tr>
<tr>
<td align="center">sigmoid</td>
<td align="center">0.7146</td>
<td align="center">27.892</td>
</tr>
<tr>
<td align="center">rbf</td>
<td align="center">0.9273</td>
<td align="center">11.822</td>
</tr>
</tbody>
</table>
<p>Le kernel RBF peut Ãªtre rÃ©gularisÃ© grÃ¢ce Ã  deux paramÃ¨tres; $C$ et $\gamma$. OÃ¹ $C$ est le coefficient de pÃ©nalitÃ©, qui correspond Ã  la tolÃ©rance aux erreurs; un $C$ grand pousse le modÃ¨le Ã  apprendre parfaitement tandis qu&rsquo;un $C$ petit cherche Ã  lisser la frontiÃ¨re de dÃ©cision. Le gamma lui, dÃ©termine l&rsquo;importance de chaque individus d&rsquo;entraÃ®nement; plus le $\gamma$ est petit, plus les vecteurs de support sont nombreux, ce qui rÃ©duit la vitesse d&rsquo;entraÃ®nement et de prÃ©diction.</p>
<p>En faisant une recherche alÃ©atoire sur les deux espaces, on observe qu&rsquo;un coefficient de pÃ©nalitÃ© faible et un gamma faible amÃ©liore le rÃ©sultat.</p>
<hr>
<h2 id="arbre-de-dÃ©cision">Arbre de dÃ©cision</h2>
<h3 id="principe-2">Principe</h3>
<p>Ce modÃ¨le cherche Ã  construire une partition de l&rsquo;espace $\Omega^2$ dans laquelle l&rsquo;issue des combats dans chaque sous-ensemble est homogÃ¨ne grÃ¢ce Ã  un arbre binaire.</p>
<p>A partir de la racine qui reprÃ©sente l&rsquo;ensemble de dÃ©part, 0 Ã  2 noeuds sont ajoutÃ©s. Chaque noeud reprÃ©sente une <em>division</em>, c&rsquo;est-Ã -dire une condition sur un attribut ou une combinaison linÃ©aire d&rsquo;attributs coupant l&rsquo;ensemble en deux sous-ensemble. Cette procÃ©dure est rÃ©pÃ©tÃ©e pour chaque sous-ensemble rÃ©cursivement jusqu&rsquo;Ã  l&rsquo;obtention des partitions homogÃ¨nes au sens de la variable Ã  prÃ©dire. Afin d&rsquo;avoir une sÃ©paration optimale Ã  chaque Ã©tape, l&rsquo;algorithme cherche la division qui optimise le critÃ¨re d&rsquo;<em>impuretÃ©</em> par une recherche Ã  <em>force brute</em> (itÃ©ration sur l&rsquo;ensemble des seuils possibles).</p>
<h3 id="rÃ©gularisation">RÃ©gularisation</h3>
<p>La capacitÃ© de gÃ©nÃ©ralisation d&rsquo;un arbre par rapport Ã  son ensemble d&rsquo;apprentissage dÃ©pend fortement de sa profondeur. La dÃ©finition d&rsquo;une <strong>profondeur maximale</strong> ou d&rsquo;un nombre de noeuds maximal permettent de limiter la croissance manuellement Ã  condition qu&rsquo;une division de l&rsquo;espace soit trouvÃ©e lors des visualisations. Sinon, un \textbf{seuil minimal de dÃ©croissance d&rsquo;un critÃ¨re} entre chaque dÃ©veloppement de l&rsquo;arbre peut Ãªtre utilisÃ© pour limiter la croissance en complexitÃ© sans perdre la prÃ©cision du modÃ¨le.</p>
<h3 id="application-2">Application</h3>
<p>L&rsquo;analyse de l&rsquo;impact du paramÃ¨tre de croissance minimale d&rsquo;impuretÃ© sur la qualitÃ© du modÃ¨le de prÃ©diction de la victoire Ã  partir des diffÃ©rences montre qu&rsquo;une croissance trop ralenti ($c_{min}&gt;0.4$) entraÃ®ne un sous-apprentissage et une croissance non contrÃ´lÃ©e un sur-apprentissage.</p>
<p>De plus, l&rsquo;optimum global obtenu Ã  $c_{min} = 0.15$ est commun entre les deux critÃ¨res de puretÃ© et produit deux arbres Ã©quivalents de profondeur 2. La bonne qualitÃ© de la prÃ©diction ($94.5%$ de bonne prÃ©diction Ã  l&rsquo;issu d&rsquo;une validation croisÃ©e Ã  5 coupes) s&rsquo;accompagne aussi de l&rsquo;interprÃ©tabilitÃ© car le modÃ¨le revient Ã  deux conditions sur la diffÃ©rence de vitesse et d&rsquo;attaque entre les deux pokÃ©mon.</p>
<p>
<img src="/img/pokemon_tree_differences_entropy.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Arbres de dÃ©cision de la diffÃ©rences des statistiques des combats et matrice de confusion sur l&#39;Ã©chantillon de test de 12466 individus</p></p>
<p>La matrice de confusion rÃ©vÃ¨le tout de mÃªme qu&rsquo;une grande partie des erreurs de classification commises s&rsquo;explique par une sur-estimation de la capacitÃ© du premier pokÃ©mon. Ceci peut provenir d&rsquo;un lÃ©ger biais pour la perte du premier pokÃ©mon que nous allons tenter de prendre en compte dans la partie ForÃªt AlÃ©atoire.</p>
<p>De plus, l&rsquo;arbre de dÃ©cision produit un estimateur de variance Ã©levÃ©e; les sÃ©parations sont optimisÃ©es localement et souvent sous-optimales, et donc chaque changement lÃ©ger dans les donnÃ©es produit des arbres complÃ¨tement diffÃ©rent.</p>
<h2 id="forÃªt-alÃ©atoire">ForÃªt alÃ©atoire</h2>
<h3 id="principe-3">Principe</h3>
<p>La forÃªt alÃ©atoire permet de rÃ©gler le problÃ¨me de la variance des arbres de dÃ©cision en regroupant plusieurs arbres en un modÃ¨le plus complexe.</p>
<p>L&rsquo;algorithme consiste d&rsquo;abord Ã  crÃ©er $N$ rÃ©plications des donnÃ©es initiales $D$ par tirages avec remise, nommÃ©s les Ã©chantillons de bootstrap $D^*_b$. On entraÃ®ne alors les arbres de dÃ©cisions $A_b$ avec les donnÃ©es d&rsquo;entraÃ®nements $D^*_b$ par un algorithme CART lÃ©gÃ¨rement modifiÃ©; le dÃ©coupage choisi correspond Ã  la sÃ©paration qui optimise le critÃ¨re d&rsquo;impuretÃ© sur un ensemble d&rsquo;attributs tirÃ© alÃ©atoirement parmi les attributs. Finalement, le classement d&rsquo;un individu se fait par vote majoritaire des arbres.</p>
<p>En moyennant les prÃ©dictions d&rsquo;un groupe d&rsquo;arbre, on rÃ©duit la variance des arbres individuelles et en construisant des arbres sur des Ã©chantillons diffÃ©rentes et des attributs diffÃ©rents, on diminue le biais du modÃ¨le.</p>
<h3 id="application-3">Application</h3>
<p>La rÃ©gularisation d&rsquo;une forÃªt est similaire Ã  celle d&rsquo;un arbre mise Ã  part le paramÃ¨tre du nombre d&rsquo;arbres qui constituent la forÃªt. De plus, afin de rÃ©duire l&rsquo;effet du biais nÃ©gative des donnÃ©es, on peut attribuer d&rsquo;un poids Ã  chaque classe pondÃ¨re la proportion des classes dans le calcul des critÃ¨res d&rsquo;impuretÃ©:</p>
<p>$$C_l(p) = p_l^{-}(1 - p_l^{-}) + p_l^{+}(1 - p_l^{+})$$</p>
<p>$$avec\ p_l^{-} = \frac{n_l^{-} \times w^{-}}{n_l}$$</p>
<p>Avec $C$ le critÃ¨re d&rsquo;impuretÃ©, $p^{+}<em>l$ les proportions Ã  un noeud $l$ des diffÃ©rentes classes pour les individus de l&rsquo;arbre infÃ©rieur au seuil et $\omega</em>{+}$ le poids associÃ© Ã  la classe Victoire du premier pokÃ©mon. Dans ce problÃ¨me binaire, en augmentant le poids d&rsquo;une modalitÃ©, on augmente son influence sur la croissance de l&rsquo;arbre et on rÃ©duit en mÃªme temps la modalitÃ© inverse.</p>
<p>En associant un poids plus important Ã  la dÃ©faite, la qualitÃ© des prÃ©dictions des arbres binaires et des forÃªts alÃ©atoires s&rsquo;amÃ©liorent de maniÃ¨re nÃ©gligeable. La fluctuation de la qualitÃ© des prÃ©dictions par rapport aux poids des classes pour l&rsquo;arbre de dÃ©cision peut s&rsquo;expliquer par la variance importante du modÃ¨le et ne peut donc pas Ãªtre prise en compte. MÃªme en utilisant l&rsquo;option <em>balanced</em> pour les poids des classes sur sklearn et en augmentant le nombre de plis de la validation, aucune diffÃ©rence statistique pertinente est observable. L&rsquo;observation que nous avons fait au niveau du biais des donnÃ©es n&rsquo;affecte donc pas le classifieur.</p>
<p>
<img src="/img/pokemon_balance_difference.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">QualitÃ© du modÃ¨le de prÃ©diction des taux de victoire par rapport aux poids attribuÃ©s Ã  chaque classe (sans optimisation d&#39;autres hyper-paramÃ¨tres)</p></p>
<hr>
<h2 id="adaptative-boosting">Adaptative Boosting</h2>
<h3 id="principe-4">Principe</h3>
<p>Le boosting est une mÃ©thode qui consiste Ã  construire sÃ©quentiellement une suite de modÃ¨les simples pour constituer un modÃ¨le plus puissant.</p>
<p>Pour un problÃ¨me de classification binaire d&rsquo;une variable $y$, l&rsquo;algorithme Adaboost considÃ¨re que les individus sont tous initialement uniformÃ©ment pondÃ©rÃ©s. A l&rsquo;itÃ©ration $i$, un nouveau modÃ¨le $M^i$ est construit avec le modÃ¨le de base sur l&rsquo;Ã©chantillon d&rsquo;entraÃ®nement avec le poids courant des individus. Son taux d&rsquo;erreur $\varepsilon^i$ de classification est alors calculÃ© puis le poids $\alpha^i$
ainsi que la pondÃ©ration des individus $\omega_j$ qui sera ensuite normalisÃ©e. L&rsquo;algorithme converge lorsque le nombre de modÃ¨les est satisfait ou lorsque l&rsquo;erreur est plus petite qu&rsquo;un seuil donnÃ©.</p>
<p>$$\varepsilon^i = \frac{\sum_{j=1}^n\omega_j\unicode{x1D7D9}(y_j \neq M^i(j))}{\sum_{j=1}^n\omega_j}$$</p>
<p>$$\alpha^i = log\left(\frac{1 - \varepsilon^i}{\varepsilon^i}\right)$$</p>
<p>$$\omega_j^{i+1} = \omega_j^{i} \times exp(\alpha^i \times \unicode{x1D7D9}(y_j \neq M^i(j)))$$</p>
<p>La mise Ã  jour de la pondÃ©ration des individus attribue un poids plus important aux individus mal classifiÃ©s, ce qui incite le modÃ¨le de boosting sur les itÃ©rations suivantes Ã  corriger les zones problÃ©matiques en terme de classification. Cet avantage est Ã  double tranchant puisqu&rsquo;il rend le modÃ¨le plus sensible aux donnÃ©es bruitÃ©es ainsi qu&rsquo;Ã  une mauvaise classification.</p>
<p>En gÃ©nÃ©rale, Adaboost fonctionne mieux avec des modÃ¨les de base simples avec des puissances de prÃ©diction faible comme les arbres de dÃ©cision.</p>
<h3 id="application-4">Application</h3>
<p>L&rsquo;application d&rsquo;Adaboost sur l&rsquo;arbre de dÃ©cision donne un rÃ©sultat similaire Ã  un arbre simple. Ce s&rsquo;explique par la complexitÃ© de l&rsquo;arbre optimal initial (de profondeur 5) ainsi que la prÃ©sence des rÃ©sultats inattendus de certains combats (victoire d&rsquo;un pokÃ©mon dÃ©favorisÃ© Ã  l&rsquo;Ã©gard des statistiques de combats) auxquelles le modÃ¨le est plus sensible.</p>
<p>
<img src="/img/pokemon_pdp_difference.jpg"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Graphique de dÃ©pendance partielle des variables les plus importantes du modÃ¨le Adaboost de prÃ©diction des combats</p></p>
<p>Le graphique de dÃ©pendance (reprÃ©sentation qui montre l&rsquo;influence d&rsquo;une ou de plusieurs variables marginales sur la prÃ©diction. Pour un problÃ¨me de classification binaire, toute zone de probabilitÃ© $&gt;0.5$ correspond Ã  un $True$.) montre une rupture des frontiÃ¨res de dÃ©cision claire qui se produit au niveau de <em>diff_speed</em> $= 0$. La dÃ©pendance partielle de la diffÃ©rence de vitesse va contre l&rsquo;intuition que la diffÃ©rence de vitesse influence linÃ©airement la probabilitÃ© de victoire du pokÃ©mon avantagÃ©.</p>
<p>La forme inattendue ($1/x$) que prend la dÃ©pendance partielle des diffÃ©rence de vitesse peut s&rsquo;expliquer par la dominance des diffÃ©rences des taux de victoires dans le modÃ¨le. L&rsquo;inclusion de cette variable bruitÃ©e affaiblit fortement le modÃ¨le. Sa suppression engendre alors une amÃ©lioration visible du taux de prÃ©diction correcte de $0.909$ Ã  $0.940$ et une correction de l&rsquo;Ã©volution de la dÃ©pendance partielle.</p>
<hr>
<h2 id="conclusion">Conclusion</h2>
<h3 id="Ã©valuation-des-performances">Ã‰valuation des performances</h3>
<p>Afin de comparer les performances entre diffÃ©rentes familles d&rsquo;algorithmes, la procÃ©dure commune suivante a Ã©tÃ© suivie:</p>
<ul>
<li>Le jeu de donnÃ©es est divisÃ© en un Ã©chantillon d&rsquo;entraÃ®nement et de test ($33%$ des donnÃ©es) grÃ¢ce Ã  GridSearchCV.</li>
<li>L&rsquo;estimateur de performance choisie est l&rsquo;accuracy_score qui calcule la correspondance exacte de la prÃ©diction et de la classe rÃ©elle par la formule:
$$\texttt{accuracy}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} \unicode{x1D7D9}(\hat{y}_i = y_i)$$
Cet indicateur correspond bien Ã  notre cas d&rsquo;usage puisqu&rsquo;il s&rsquo;agit d&rsquo;un problÃ¨me de classification binaire oÃ¹ le rÃ©sultat d&rsquo;un combat est dÃ©terministe.</li>
<li>Le critÃ¨re de qualitÃ© est alors calculÃ© par validation croisÃ©e Ã  cinq coupes afin de rÃ©duire le biais et optimisÃ© sur l&rsquo;espace d&rsquo;hyper-paramÃ¨tre correspondant.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">ModÃ¨les</th>
<th align="center">Accuracy score</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">KNN</td>
<td align="center">0.92</td>
</tr>
<tr>
<td align="center">SVM</td>
<td align="center">0.9273</td>
</tr>
<tr>
<td align="center">Arbre de dÃ©cision</td>
<td align="center">0.945</td>
</tr>
<tr>
<td align="center">ForÃªt alÃ©atoire</td>
<td align="center">0.949</td>
</tr>
<tr>
<td align="center">AdaBoost dâ€™arbre</td>
<td align="center">0.940</td>
</tr>
</tbody>
</table>
<p>MÃªme avec une Ã©valuation pessimiste de la qualitÃ©, les modÃ¨les construits peuvent tous rÃ©pondre adÃ©quatement Ã  notre problÃ©matique.</p>
<p>Afin de minimiser le temps d&rsquo;entraÃ®nement, d&rsquo;optimiser la qualitÃ© du modÃ¨le et de maintenir l&rsquo;interprÃ©tabilitÃ©, l&rsquo;arbre de dÃ©cision correspond au choix optimal pour notre jeu de donnÃ©es synthÃ©tiques. On peut alors Ã©mettre l&rsquo;hypothÃ¨se suivante sur la gÃ©nÃ©ration des donnÃ©es : la victoire est gÃ©nÃ©rÃ©e selon deux conditions sur la diffÃ©rence de vitesse et d&rsquo;attaque entre les deux pokÃ©mons puis du bruit alÃ©atoire introduit pour complexifier la classification.</p>
<h3 id="conclusions-et-futurs-travaux">Conclusions et futurs travaux</h3>
<p>Ce projet nous a permis d&rsquo;appliquer et de comprendre les algorithmes de classification vus en cours sur un jeu de donnÃ©es &ldquo;rÃ©elles&rdquo; et d&rsquo;explorer d&rsquo;autres modÃ¨les comme les SVM ou l&rsquo;Adaboost. Il nous a aussi fait comprendre l&rsquo;importance de l&rsquo;analyse prÃ©liminaire et du nettoyage dans la construction d&rsquo;un modÃ¨le d&rsquo;apprentissage automatique.</p>
<p>Pour aller plus loin, on peut Ã©tudier d&rsquo;autres algorithmes comme la rÃ©gression logistique ou les analyses discriminantes. De plus, on peut identifier et Ã©tudier les zones problÃ©matiques pour chaque classifieur et dÃ©terminer si certains attributs suivent une distribution particuliÃ¨re dans ces zones. Puis dans un deuxiÃ¨me temps, scinder le jeu de donnÃ©es en partie problÃ©matique et non problÃ©matique puis appliquer des modÃ¨les diffÃ©rentes Ã  chaque partie. Enfin, afin d&rsquo;obtenir un jeu de donnÃ©es plus reprÃ©sentatif du jeu PokÃ©mon, peut-Ãªtre que rÃ©cupÃ©rer les rÃ©sultats de combats rÃ©ellement jouÃ©s par des joueurs serait pertinent. Des applications comme &ldquo;PokÃ©mon Showdown&rdquo; le permettent.</p>

            </div>
        </article>
        <h2 id="end"></h2>
        <hr />

        <div class="post-info">
  				<p>
  					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://ichbinfrog.github.io/tags/ml">ml</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/pokemon">pokemon</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/svm">svm</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/knn">knn</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/decision-tree">decision tree</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/random-forest">random forest</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/adaboost">adaboost</a></span>
  				</p>
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2022</span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span><a href="https://themes.gohugo.io/hugo-theme-hello-friend-ng/">hello-friend-ng</a> Theme for <a href="http://gohugo.io">Hugo</a> by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.dc716e9092c9820b77f96da294d0120aeeb189b5bcea9752309ebea27fd53bbe6b13cffb2aca8ecf32525647ceb7001f76091de4199ac5a3caa432c070247f5b.js" integrity="sha512-3HFukJLJggt3&#43;W2ilNASCu6xibW86pdSMJ6&#43;on/VO75rE8/7KsqOzzJSVkfOtwAfdgkd5BmaxaPKpDLAcCR/Ww=="></script>



    </body>
</html>
