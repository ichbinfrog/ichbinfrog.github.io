<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Ce travail a √©t√© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&amp;rsquo;UV SY09.
  Issu d&amp;rsquo;une franchise de jeu vid√©o japonaise, un pok√©mon est une cr√©ature qui, une fois captur√©e par un dresseur, peut-√™tre envoy√© pour affronter les pok√©mon d&amp;rsquo;un autre dresseur. R√©gi par un ensemble de r√®gles bien d√©finies, la complexit√© des combats qui en d√©rive et les mod√®les qui les pr√©disent constituent l&amp;rsquo;int√©r√™t de cette √©tude." />
<meta name="keywords" content=", ml, pokemon, svm, knn, decision tree, random forest, adaboost" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://ichbinfrog.github.io/university/pokemon/" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: { autoNumber: "AMS" },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(), i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({
        
        TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
</script>


    <title>
        
            üá´üá∑ Pokemon victory prediction :: Hoang Quoc Trung 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.cbd9ce6c3a26d6c4a5eb4b8834c18d83518654bd8bac1fc8160486f336181c9a.css">


    
        <link rel="stylesheet" type="text/css" href="/css/post.css">
    





<meta itemprop="name" content="üá´üá∑ Pokemon victory prediction">
<meta itemprop="description" content="Ce travail a √©t√© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&rsquo;UV SY09.
  Issu d&rsquo;une franchise de jeu vid√©o japonaise, un pok√©mon est une cr√©ature qui, une fois captur√©e par un dresseur, peut-√™tre envoy√© pour affronter les pok√©mon d&rsquo;un autre dresseur. R√©gi par un ensemble de r√®gles bien d√©finies, la complexit√© des combats qui en d√©rive et les mod√®les qui les pr√©disent constituent l&rsquo;int√©r√™t de cette √©tude.">
<meta itemprop="datePublished" content="2020-06-30T11:55:00&#43;00:00" />
<meta itemprop="dateModified" content="2020-06-30T11:55:00&#43;00:00" />
<meta itemprop="wordCount" content="4110">
<meta itemprop="image" content="https://ichbinfrog.github.io/"/>



<meta itemprop="keywords" content="ml,pokemon,svm,knn,decision tree,random forest,adaboost," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ichbinfrog.github.io/"/>

<meta name="twitter:title" content="üá´üá∑ Pokemon victory prediction"/>
<meta name="twitter:description" content="Ce travail a √©t√© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&rsquo;UV SY09.
  Issu d&rsquo;une franchise de jeu vid√©o japonaise, un pok√©mon est une cr√©ature qui, une fois captur√©e par un dresseur, peut-√™tre envoy√© pour affronter les pok√©mon d&rsquo;un autre dresseur. R√©gi par un ensemble de r√®gles bien d√©finies, la complexit√© des combats qui en d√©rive et les mod√®les qui les pr√©disent constituent l&rsquo;int√©r√™t de cette √©tude."/>



    <meta property="og:title" content="üá´üá∑ Pokemon victory prediction" />
<meta property="og:description" content="Ce travail a √©t√© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&rsquo;UV SY09.
  Issu d&rsquo;une franchise de jeu vid√©o japonaise, un pok√©mon est une cr√©ature qui, une fois captur√©e par un dresseur, peut-√™tre envoy√© pour affronter les pok√©mon d&rsquo;un autre dresseur. R√©gi par un ensemble de r√®gles bien d√©finies, la complexit√© des combats qui en d√©rive et les mod√®les qui les pr√©disent constituent l&rsquo;int√©r√™t de cette √©tude." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ichbinfrog.github.io/university/pokemon/" />
<meta property="og:image" content="https://ichbinfrog.github.io/"/>
<meta property="article:published_time" content="2020-06-30T11:55:00+00:00" />
<meta property="article:modified_time" content="2020-06-30T11:55:00+00:00" /><meta property="og:site_name" content="Hoang Quoc Trung" />






    <meta property="article:published_time" content="2020-06-30 11:55:00 &#43;0000 UTC" />








    </head>

    <body class="">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">ichbinfrog</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="https://ichbinfrog.github.io/projects">0_projects</a></li><li><a href="https://ichbinfrog.github.io/internships">1_internships</a></li><li><a href="https://ichbinfrog.github.io/university">2_uni_works</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title" id="top"><a href="https://ichbinfrog.github.io/university/pokemon/">üá´üá∑ Pokemon victory prediction</a></h2>
            <aside id="toc"><style>
.toc {
    position: fixed;
    top: 50%;
    left: 2%;
    width: 20%;
    transform: translateY(-50%);
    border-radius: 5px;
    padding-bottom: 1rem;
}

.toc a {
    text-decoration: none;
    color: gray;
}

.toc a:hover {
    opacity: 0.5;
}

.toc ul {
    list-style: ">  ";
}

.toc-title {
    text-decoration: underline;
}
</style>

<div class="toc">
    <div class="toc-title">Table of Contents</div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#analyse-exploratoire">Analyse exploratoire</a>
      <ul>
        <li><a href="#caract√©ristiques-dun-pok√©mon">Caract√©ristiques d&rsquo;un pok√©mon</a></li>
        <li><a href="#combats">Combats</a></li>
        <li><a href="#probl√©matique">Probl√©matique</a></li>
      </ul>
    </li>
    <li><a href="#enrichissement-du-jeu-de-donn√©es">Enrichissement du jeu de donn√©es</a>
      <ul>
        <li><a href="#introduction-dune-hi√©rarchie">Introduction d&rsquo;une hi√©rarchie</a></li>
      </ul>
    </li>
    <li><a href="#r√©duction-des-dimensions">R√©duction des dimensions</a>
      <ul>
        <li><a href="#analyse-en-composantes-principales">Analyse en composantes principales</a></li>
        <li><a href="#matrice-de-distance-interm√©diaire">Matrice de distance interm√©diaire</a></li>
      </ul>
    </li>
    <li><a href="#k-plus-proches-voisins-knn">K Plus Proches Voisins (KNN)</a>
      <ul>
        <li><a href="#principe">Principe</a></li>
        <li><a href="#application">Application</a></li>
      </ul>
    </li>
    <li><a href="#support-vector-machine-svm">Support Vector Machine (SVM)</a>
      <ul>
        <li><a href="#principe-1">Principe</a></li>
        <li><a href="#application-1">Application</a></li>
      </ul>
    </li>
    <li><a href="#arbre-de-d√©cision">Arbre de d√©cision</a>
      <ul>
        <li><a href="#principe-2">Principe</a></li>
        <li><a href="#r√©gularisation">R√©gularisation</a></li>
        <li><a href="#application-2">Application</a></li>
      </ul>
    </li>
    <li><a href="#for√™t-al√©atoire">For√™t al√©atoire</a>
      <ul>
        <li><a href="#principe-3">Principe</a></li>
        <li><a href="#application-3">Application</a></li>
      </ul>
    </li>
    <li><a href="#adaptative-boosting">Adaptative Boosting</a>
      <ul>
        <li><a href="#principe-4">Principe</a></li>
        <li><a href="#application-4">Application</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a>
      <ul>
        <li><a href="#√©valuation-des-performances">√âvaluation des performances</a></li>
        <li><a href="#conclusions-et-futurs-travaux">Conclusions et futurs travaux</a></li>
      </ul>
    </li>
  </ul>
</nav>
    <ul>
    <li><a href="#top">Top</a></li>
    <li><a href="#end">End</a></li>
    </ul>
</div></aside>

            

            <div class="post-content">
                <blockquote>
<p>Ce travail a √©t√© fait avec Alix CANDUSSO et Chen GONG dans le cadre de l&rsquo;UV SY09.</p>
</blockquote>
<blockquote>
<p>Issu d&rsquo;une franchise de jeu vid√©o japonaise, un pok√©mon est une cr√©ature qui, une fois captur√©e par un dresseur, peut-√™tre envoy√© pour affronter les pok√©mon d&rsquo;un autre dresseur. R√©gi par un ensemble de r√®gles bien d√©finies, la complexit√© des combats qui en d√©rive et les mod√®les qui les pr√©disent constituent l&rsquo;int√©r√™t de cette √©tude.</p>
</blockquote>
<h2 id="analyse-exploratoire">Analyse exploratoire</h2>
<p>Cette collection, provenant de <a href="https://www.kaggle.com/terminus7/pokemon-challenge%22">Kaggle</a>, est constitu√©e de trois jeu de donn√©es diff√©rents;</p>
<h3 id="caract√©ristiques-dun-pok√©mon">Caract√©ristiques d&rsquo;un pok√©mon</h3>
<p>Ce jeu de donn√©es pr√©sente les caract√©ristiques de 800 pok√©mon extraites directement du code objet du jeu. Chaque pok√©mon, identifi√© de mani√®re unique par un nom ou un entier, se caract√©rise par un bool√©en qui indique s&rsquo;il est <strong>l√©gendaire</strong> ainsi que par sa <strong>g√©n√©ration</strong> (&ldquo;version&rdquo; √† partir de laquelle le pok√©mon a √©t√© ajout√©). Un pok√©mon est aussi caract√©ris√© par ses statistiques;</p>
<ul>
<li><strong>speed</strong>: d√©termine s&rsquo;il prend l&rsquo;initiative lors d&rsquo;un combat</li>
<li><strong>hp</strong>: nombre de point de dommages qu&rsquo;il peut subir avant d&rsquo;√™tre √©limin√©</li>
<li><strong>attack</strong>: puissance de ses attaques physiques</li>
<li><strong>defense</strong>: r√©sistance aux attaques physiques</li>
<li><strong>sp. attack</strong>: puissance des attaques &ldquo;magiques&rdquo; (le pokemon ne touche physiquement pas son adversaire mais inflige tout de m√™me des d√©g√¢ts)</li>
<li><strong>sp. defense</strong>: r√©sistance aux attaques sp√©ciales</li>
</ul>
<p>Normalement, les statistiques d&rsquo;un pok√©mon sont bas√©es sur des statistiques de base augmentent lorsque le pok√©mon monte en niveau, mais cette dimension n&rsquo;est pas consid√©r√©e dans ce jeu de donn√©es. De plus, chaque pok√©mon appartient √† un ou deux <strong>types</strong> (e.g. Feu, Eau, Acier, √âlectricit√©, Vol&hellip;) qui indique quelles capacit√©s peuvent √™tre apprises et ses forces/faiblesses par rapport √† des pok√©mon d&rsquo;autres types (e.g. les pokemon de type Feu sont plus vuln√©rables aux attaques de type Eau, mais plus r√©sistants aux attaques de type Plante).</p>
<h3 id="combats">Combats</h3>
<p>Ce tableau pr√©sente les codes des bellig√©rants de 50001 duels et le vainqueur. Ces triplets synth√©tiques sont g√©n√©r√©s par un algorithme qui simplifie certains aspects du jeu notamment les capacit√©s. En r√©alit√©, un combat se d√©roule selon les r√®gles suivantes:</p>
<ul>
<li>Le pok√©mon pr√©sent dans la premi√®re colonne dispose de l&rsquo;initiative pour le premier tour.</li>
<li>√Ä chaque tour, chaque pok√©mon choisit et utilise une de ses quatre capacit√©s (une attaque physique ou sp√©ciale, une attaque de modification de statistiques, etc) jusqu&rsquo;√† ce que les points de vie de l&rsquo;un des deux tombe √† 0 et la victoire est alors accord√©e √† l&rsquo;autre.</li>
</ul>
<p>Afin d&rsquo;all√©ger la notation, notons dor√©navant $\Omega$ (l&rsquo;ensemble des pok√©mon) et donc $\Omega^2$ (l&rsquo;ensemble des statistiques de deux pok√©mon qui s&rsquo;affrontent en duel).</p>
<p>En interpolant √† partir des donn√©es sur les combats, on peut √©mettre l&rsquo;hypoth√®se que le r√©sultat d&rsquo;un combat entre deux pok√©mons est <strong>d√©terministe</strong> car:</p>
<ul>
<li>Il n&rsquo;y a pas de combats o√π un pok√©mon affronte l&rsquo;exact m√™me pok√©mon. Si ce cas de figure existe, les deux bellig√©rants auraient exactement les m√™mes statistiques de combats et le r√©sultat devrait donc √™tre soit d√©cid√© de mani√®re al√©atoire soit une <em>√©galit√©</em>.</li>
<li>Il n&rsquo;y a pas deux combats entre $p_1$ et $p_2$ o√π dans l&rsquo;un $p_1$ attaque en premier et dans l&rsquo;autre il attaque en deuxi√®me.</li>
<li>Chaque combat a un gagnant unique.</li>
</ul>
<p>Il est donc possible de construire un classifieur binaire pour pr√©dire le r√©sultat d&rsquo;un combat o√π $True$ correspond √† la victoire du premier pok√©mon qui attaque et $False$ sinon. N√©anmoins, seulement $14.409%$ des combinaisons de paires possibles de pok√©mon sont repr√©sent√©es donc notre mod√®le sera entra√Æn√© sur une partie relativement petite de l&rsquo;ensemble $\Omega^2$. Un √©chantillon de test accompagne aussi la table des combats. Tout de m√™me, celui-ci est inutile pour v√©rifier la validit√© du mod√®le car il ne pr√©sente pas le code du vainqueur.</p>
<h3 id="probl√©matique">Probl√©matique</h3>
<p>Le but ce cette √©tude est donc d&rsquo;appliquer un large √©ventail d&rsquo;algorithmes d&rsquo;apprentissage supervis√©s et non supervis√©s afin de construire un mod√®le, qui, prend en entr√©e deux pok√©mon et pr√©dit le gagnant.</p>
<hr>
<h2 id="enrichissement-du-jeu-de-donn√©es">Enrichissement du jeu de donn√©es</h2>
<h3 id="introduction-dune-hi√©rarchie">Introduction d&rsquo;une hi√©rarchie</h3>
<p>Un pok√©mon dispose parfois d&rsquo;une cha√Æne d&rsquo;√©volution (e.g. Salam√®che $\rightarrow$ Reptincel $\rightarrow$ Dracaufeu), les pok√©mon en fin de cha√Æne √©tant en g√©n√©ral plus puissants que ceux en d√©but. Afin de tester si cette cat√©gorisation hi√©rarchique contribue √† la am√©liorer la classification, nous avons introduit le stage d&rsquo;√©volution d&rsquo;un pokemon (0 √©tant l&rsquo;√©tat en d√©but de cha√Æne d&rsquo;√©volution qui incr√©mente de 1 jusqu&rsquo;√† ce qu&rsquo;on atteint un pok√©mon en fin de cha√Æne) gr√¢ce √† <a href="https://pokeapi.co/">PokeAPI</a>.</p>
<p><strong>Ajout d&rsquo;une m√©trique</strong></p>
<p>Afin de combiner le jeu de donn√©es des pok√©mon et des combats, il est possible de comprimer le tableau de combats en une seule m√©trique, le taux de victoire avec la formule:</p>
<p>$$win\_rate(p_i) = \frac{nombre\_de\_victoires(p_i)}{nombre\_de\_combats(p_i)}$$</p>
<p><p style="text-align:center; font-style: italic; padding-bottom: 15px;">Matrice des corr√©lations des caract√©ristiques des pok√©mon</p>

<img src="/img/pokemon_heatmap.png"  class="center"  />

</p>
<p>La matrice de corr√©lation issue du jeu de donn√©e enrichi d√©montre une corr√©lation forte entre la vitesse d&rsquo;un pok√©mon et son taux de victoire ainsi que le niveau d&rsquo;√©volution et la g√©n√©ration. La deuxi√®me relation s&rsquo;explique par l&rsquo;introduction des cha√Ænes d&rsquo;√©volutions plus longues au fur et √† mesure de la parution de nouveaux jeux Pok√©mon (e.g. √©volutions m√©ga, X ou Y).</p>
<p>Il est tout de m√™me surprenant que les attributs de d√©fenses (hp, defense, sp. defense) affectent tr√®s peu le taux de victoire du pok√©mon. Au contraire, les attributs offensifs (speed, attack, sp. attack) sont plus fortement corr√©l√©s √† la probabilit√© de gagner un duel.</p>
<p>
<img src="/img/pokemon_reg.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Regr√©ssion des attributs les plus fortement corr√©l√©s au taux de victoire</p></p>
<p>De m√™me, le jeu de donn√©es des combats peut √™tre enrichi en ajoutant les caract√©ristiques de chaque participants. Tout de m√™me, le tableau individu-variable de taille importante ($50001$ lignes et $21$ colonnes) qui en r√©sulte ralentit l&rsquo;entra√Ænement des algorithmes et augmente la quantit√© de ressource consomm√©e. Il sera donc n√©cessaire de r√©duire ses dimensions via des algorithmes lin√©aires (PCA) lin√©aire ou en agr√©geant les attributs en des m√©triques plus cons√©quentes.</p>
<p>Au lieu de consid√©rer les attributs attaque/attaque sp√©ciale et d√©fense/d√©fense sp√©ciale, il est aussi possible d&rsquo;additionner les deux statistiques pour en former une statistique <em>attaque</em> et <em>d√©fense</em> plus g√©n√©rale (ce jeu de donn√©e s&rsquo;appellera d√©sormais <em>reduced_diff</em>).</p>
<p><strong>Impact des types</strong></p>
<p>Afin d&rsquo;√©tudier l&rsquo;impact des m√©canismes de faiblesse par rapport aux types des deux combattants sur l&rsquo;issue du duel, deux attributs ont √©t√© ajout√©s, le multiplicateur de puissance d&rsquo;attaque de chacun des pok√©mon. Ces derni√®res r√©duisent quatre valeurs qualitatives (cat√©gorie) en deux valeurs quantitatives gr√¢ce √† la formule:</p>
<p>$$\tau_{type_1(p_1),type_1(p_2)} \times \tau_{type_1(p_1),type_2(p_2)}$$</p>
<p>$$\tau_{type_2(p_1),type_1(p_2)} \times \tau_{type_2(p_1),type_2(p_2))}$$</p>
<p>Avec $\tau$ la matrice des multiplicateurs de la puissance d&rsquo;attaque de la VII√®me g√©n√©ration, avec $\tau_{t_1,t_2} \in \mathbb{R}^+$ le multiplicateur d&rsquo;attaquant de type $t_1$ par rapport √† un d√©fendant de type $t_2$. Afin d&rsquo;obtenir le multiplicateur dans le sens inverse, il suffit de prendre $mult(p_2, p_1)$.</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">victoire du 1er pok√©mon</th>
<th align="center">victoire du 2nd pok√©mon</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">mult(p1,p2)&gt; mult(p2,p1)</td>
<td align="center">0.51346</td>
<td align="center">0.48654</td>
</tr>
<tr>
<td align="center">mult(p1,p2)=mult(p2,p1)</td>
<td align="center">0.481212</td>
<td align="center">0.518788</td>
</tr>
<tr>
<td align="center">mult(p1,p2)&lt; mult(p2,p1)</td>
<td align="center">0.415805</td>
<td align="center">0.584195</td>
</tr>
<tr>
<td align="center">total</td>
<td align="center">0.47202</td>
<td align="center">0.52798</td>
</tr>
</tbody>
</table>
<p>La matrice de contingence relative entre ses multiplicateurs et l&rsquo;issue du combat, r√©v√®le une inclinaison positive vers la victoire du $2^{nd}$ pok√©mon ainsi qu&rsquo;une absence de corr√©lation claire entre l&rsquo;avantage que conf√®re le type et la victoire.</p>
<hr>
<h2 id="r√©duction-des-dimensions">R√©duction des dimensions</h2>
<h3 id="analyse-en-composantes-principales">Analyse en composantes principales</h3>
<p>Pour le jeu de donn√©es des combats, la colonne <em>vainqueur</em> pose probl√®me puisqu&rsquo;elle est logiquement fortement corr√©l√©e √† <em>first_pokemon</em> et <em>second_pokemon</em> et difficilement manipulable. La conversion de l&rsquo;attribut <em>vainqueur</em> en un bool√©en qui repr√©sente si le vainqueur correspond bien au premier pok√©mon, donne un domaine $\Omega^2 \times {True, False}$ plus facile √† manipuler.</p>
<p>D√®s lors, l&rsquo;application d&rsquo;une ACP s&rsquo;av√®re utile √† cause du fl√©au de la dimension en permettant de projeter l&rsquo;espace pr√©c√©dente dans un espace $\mathbb{R}^n$ avec $n$ le nombre d&rsquo;axes factoriels. Les contributions relatives des axes d&rsquo;une ACP avec l&rsquo;ensemble du tableau r√©v√®lent un coude au niveau du deuxi√®me axe factoriel. N√©anmoins, m√™me si les premiers et deuxi√®mes axes expliquent $91.36%$ de l&rsquo;inertie totale, l&rsquo;introduction d&rsquo;un troisi√®me axe donne une structure nettement s√©par√©e entre les classes au lieu des classes confondues (axe1-axe3).</p>
<p>
<img src="/img/pokemon_battles_pca.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">ACP des combats √† trois axes factoriels.</p></p>
<h3 id="matrice-de-distance-interm√©diaire">Matrice de distance interm√©diaire</h3>
<p>Il est possible de r√©duire l&rsquo;espace sans une ACP en soustrayant les statistiques des combattants. Certaines des diff√©rences obtenues corr√®lent fortement √† l&rsquo;issue du duel. La combinaison de ces diff√©rences peut donc r√©v√©ler une fonction de distance $d:\Omega^2 \mapsto \mathbb{R}$ et une fonction de r√©gression $r: \mathbb{R} \mapsto {True, False}$ qui donne en combinaison la classification voulue : $clf = r \circ d$.</p>
<p>Tout de m√™me, la table des combats contient des variables qui ne permet pas √† l&rsquo;√©valuation. Les variables qualitatives comme le type des pok√©mon sont transform√©es par la formule des types. Les attributs bool√©ennes peuvent √™tre convertis en $0(False), 1(True)$ puis une soustrait. N√©anmoins, puisque cette conversion nu√Æt √† l&rsquo;interpr√©tabilit√© du mod√®le, les variables bool√©ennes sont alors √©limin√©es.</p>

<img src="/img/pokemon_battles_heatmap.png"  class="center"  />


<p>Pour les autres statistiques de combats et les taux de victoires, une diff√©rence absolue est utilis√©e afin de respecter la sym√©trie de la distance. Il est possible d&rsquo;utiliser la diff√©rence exacte de la diff√©rence des taux de victoires mais celle-ci n√©cessite que l&rsquo;ensemble des anciens adversaires soient relativement cons√©quentes. Or, la matrice des combats est creuse ($14%$ de remplissage).</p>
<p>$$\frac{|V(p_1) \cap Adv(p_1,p_2)| - |V(p_2)\cap Adv(p_1,p_2)|}{|Adv(p_1,p_2)|}$$</p>
<p>$$V(p_1) = vaincus, par, p_1$$</p>
<p>$$Adv(p_1) = adversaires, de, p_1$$</p>
<p>$$Adv(p_1,p_2) = Adv(p_1) \cap Adv(p_2)$$</p>
<p>De plus, il est possible de r√©duire d&rsquo;autant plus la dimension en effectuant une ACP sur ces diff√©rences. La m√©thode du coude r√©v√®le que 6 axes factoriels expliquent la majorit√© de la variance expliqu√©e.</p>
<hr>
<h2 id="k-plus-proches-voisins-knn">K Plus Proches Voisins (KNN)</h2>
<h3 id="principe">Principe</h3>
<p>L&rsquo;algorithme des KNN est une m√©thode de classification supervis√©e qui ne n√©cessite pas d&rsquo;apprentissage. Lorsque l&rsquo;on souhaite classer une nouvelle donn√©e, on rel√®ve les K plus proches voisins (en termes d&rsquo;attributs) parmi le jeu de donn√©es existant et on classe cette nouvelle donn√©e dans la classe pr√©dominante parmi les K plus proches voisins qui l&rsquo;entourent.</p>
<h3 id="application">Application</h3>
<p>En faisant varier le nombre de dimensions de la PCA, on observe que la performance de l&rsquo;algorithme sur le dataset des diff√©rences est optimale √† 6 axes factoriels. De plus, la r√©duction de la dimension semble diminuer le nombre de voisins √† partir duquel les KNNs convergent vers la qualit√© de pr√©diction optimale.</p>
<p>
<img src="/img/pokemon_knn_battles_difference_df.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Validation crois√©e √† 5 coupes des KNN en fonction du nombre K de voisins et de la dimension de l&#39;ACP</p></p>
<p>Au-del√† d&rsquo;un certain seuil de voisins, la croissance en terme de qualit√© de pr√©diction est n√©gligeable et ne justifie pas le co√ªt algorithmique suppl√©mentaire. Pour notre jeu de donn√©es, ce seuil se trouve aux alentours de 20 voisins et donne un accuracy_score de $91%$. De m√™me, l&rsquo;application sur <em>reduced_diff</em> donne les m√™mes observations mais avec une pr√©cision l√©g√®rement am√©lior√©e.</p>
<p>Par d√©faut, l&rsquo;impl√©mentation KNN de sklearn utilise une distance euclidienne pour trouver les voisins les plus proches et chaque individu est pond√©r√© de mani√®re uniforme. Le choix de la distance d√©termine en pratique la forme du volume de dimension $N$ qui d√©limite les fronti√®res d&rsquo;un point;</p>
<ul>
<li><em>euclidien</em> ($\sqrt{\Sigma(x - y)^2}$) : sph√®re de $N$ dimensions.</li>
<li><em>manhattan</em> ($\Sigma(|x - y|)$) : cube de $N$ dimensions</li>
<li><em>chebyshev</em> ($max(|x - y|)$) : cube de $N$ dimensions o√π la longueur correspond √† la distance maximale d&rsquo;un attribut entre deux individus donn√©s.</li>
</ul>
<p>La distance de <em>manhattan</em> aurait donc tendance de consid√©rer plus d&rsquo;individus comme voisins que par rapport aux autres. En appliquant sur le jeu de donn√©es, on observe que l&rsquo;utilisation de cette manhattan donne le meilleur estimateur parmi les autres distances. Une piste d&rsquo;am√©lioration serait alors d&rsquo;√©tudier l&rsquo;effet des distances qui engendrent des volumes plus important (par exemple les distances de <em>minkowski</em> avec $p \in ]0,1[$).</p>
<p>
<img src="/img/pokemon_knn_dist.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Qualit√© du mod√®le KNN selon la distance et la pond√©ration des individus apr√®s validation crois√©e √† 5 coupes</p></p>
<p>De m√™me, la qualit√© du mod√®le issu de la distance de manhattan sugg√®re qu&rsquo;il n&rsquo;est pas sur-apprenti (l&rsquo;inclusion de plus de points l&rsquo;am√©liore). On peut donc renforcer l&rsquo;effet de la distance dans l&rsquo;algorithme en donnant chaque individu un poids qui correspond √† l&rsquo;inverse de sa distance √† l&rsquo;√©l√©ment √† classifier (option <em>distance</em> sur sklearn). Cette modification am√©liore un tout petit peu la qualit√© et confirme l&rsquo;hypoth√®se pr√©c√©dente.</p>
<hr>
<h2 id="support-vector-machine-svm">Support Vector Machine (SVM)</h2>
<h3 id="principe-1">Principe</h3>
<p>Les machines √† vecteurs de support (Support Vector Machine) ont pour but de s√©parer les donn√©es en classes √† l‚Äôaide d‚Äôune fronti√®re aussi simple que possible, de telle fa√ßon que la distance entre les diff√©rents groupes de donn√©es et la fronti√®re qui les s√©pare soit maximale. Cette distance est aussi appel√©e <strong>marge</strong> et les donn√©es les plus proches de la fronti√®re sont appel√©es les <strong>vecteurs de support</strong>.</p>
<p>
<img src="/img/pokemon_svm.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Illustration d&#39;un SVM avec la fronti√®re (droite noire), les vecteurs de support (points entour√©s) et les marge (droites bleue et rouge)</p></p>
<p>Pour un probl√®me de classification binaire, la fronti√®re de d√©cision est un hyperplan d√©fini par;
$$h(x)=w^{T}x+b = 0$$</p>
<p>$x$ les donn√©es d&rsquo;entr√©e de dimension $N$, $w$ le vecteur des poids et $b$ la distance entre l&rsquo;hyperplan et l&rsquo;origine. Trouver l&rsquo;hyperplan de marge maximale revient donc √†:</p>
<p>$$\frac  {1}{2}||w||^{2}, \quad \quad l_{k}(w^{T}x_{k}+w_{0})\geq 1$$</p>
<p>avec ${\displaystyle l_{k}}$ le label du vecteur $x_k$, ${\displaystyle l_{k}} \subset {\displaystyle {-1,1}}$.  Ceci peut se r√©soudre par la m√©thode classique des multiplicateurs de Lagrange, avec le lagrangien:</p>
<p>$$L(w,b,\alpha)=\frac {1}{2}||w||^{2}-\sum_{k=1}^{p}\alpha_{k}(l_{k}(w^{T}x_{k}+b)-1)$$</p>
<p>Le lagrangien doit √™tre minimis√© par rapport √† w et b, et maximis√© par rapport √† $\alpha$. Apr√®s avoir r√©solu $\alpha$, on trouve w et b pour obtenir le mod√®le:</p>
<p>$$h(x)=\sum_{k=1}^{p}\alpha_{k}^{*}l_{k}(x\cdot x_{k})+b$$</p>
<p>Pour les probl√®mes s√©parables non lin√©aires dans l&rsquo;espace d&rsquo;origine, l&rsquo;√©chantillon peut √™tre mapp√© de l&rsquo;espace d&rsquo;origine vers un espace d&rsquo;entit√©s de dimension sup√©rieure, de sorte que l&rsquo;√©chantillon est s√©parable lin√©airement dans cet espace d&rsquo;entit√©s gr√¢ce √† une fonction de noyau (<strong>kernel</strong>).</p>
<h3 id="application-1">Application</h3>
<p>La cl√© de l&rsquo;application d&rsquo;une SVM r√©side dans la s√©lection des fonctions du noyau. Les fonctions de noyau doivent correspondre √† un produit scalaire et les plus couramment utilis√©es comprennent:
\begin{itemize}</p>
<ul>
<li>
<p><strong>noyau lin√©aire</strong> : sans changement d&rsquo;espace, on se ram√®ne √† une classification lin√©aire.</p>
</li>
<li>
<p><strong>noyau polynomial</strong> :
$K(u,v) = (coef0 + \langle u, v\rangle)^d$ avec $d$ le degr√© du polyn√¥me; un degr√© de $1$ revient √† faire un noyau lin√©aire et √† des degr√©s trop grand, le mod√®le risque de sur-apprendre.</p>
</li>
<li>
<p><strong>fonction de base radiale</strong> :
$K(u,v) = exp(-\gamma \times\Vert u, v\Vert)$. Cette fonction donne en g√©n√©rale des bons r√©sultats pour des s√©parations non lin√©aires.</p>
</li>
<li>
<p><strong>noyau sigmo√Øde</strong>:
$K(u,v) = tanh(\gamma \times\Vert u, v\Vert + coef0)$</p>
</li>
</ul>
<p>La Figure suivante permet de visualiser la diff√©rence des marges et de la fronti√®re entre les noyaux. Tout de m√™me, il n&rsquo;est pas possible de visualiser les donn√©es √† dimension $&gt; 2$ et donc d&rsquo;estimer quel kernel est le mieux adapt√©.</p>
<p>
<img src="/img/pokemon_svm_kernel.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Comparaison de la fronti√®re des diff√©rentes kernel sur une PCA √† deux dimensions des diff√©rences des pok√©mons</p></p>
<p>En testant tout les kernels de base dans la librairie de sklearn, l&rsquo;utilisation d&rsquo;un kernel RBF donne en moyenne un meilleur estimateur ainsi que le temps d&rsquo;entra√Ænement le plus rapide pour notre jeu de donn√©es.</p>
<table>
<thead>
<tr>
<th align="center">kernel</th>
<th align="center">accuracy score moyenne (cv 5)</th>
<th align="center">temps d‚Äôentra√Ænement moyen (en s)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">linear</td>
<td align="center">0.899007</td>
<td align="center">3981</td>
</tr>
<tr>
<td align="center">poly</td>
<td align="center">0.864955</td>
<td align="center">20.998</td>
</tr>
<tr>
<td align="center">sigmoid</td>
<td align="center">0.7146</td>
<td align="center">27.892</td>
</tr>
<tr>
<td align="center">rbf</td>
<td align="center">0.9273</td>
<td align="center">11.822</td>
</tr>
</tbody>
</table>
<p>Le kernel RBF peut √™tre r√©gularis√© gr√¢ce √† deux param√®tres; $C$ et $\gamma$. O√π $C$ est le coefficient de p√©nalit√©, qui correspond √† la tol√©rance aux erreurs; un $C$ grand pousse le mod√®le √† apprendre parfaitement tandis qu&rsquo;un $C$ petit cherche √† lisser la fronti√®re de d√©cision. Le gamma lui, d√©termine l&rsquo;importance de chaque individus d&rsquo;entra√Ænement; plus le $\gamma$ est petit, plus les vecteurs de support sont nombreux, ce qui r√©duit la vitesse d&rsquo;entra√Ænement et de pr√©diction.</p>
<p>En faisant une recherche al√©atoire sur les deux espaces, on observe qu&rsquo;un coefficient de p√©nalit√© faible et un gamma faible am√©liore le r√©sultat.</p>
<hr>
<h2 id="arbre-de-d√©cision">Arbre de d√©cision</h2>
<h3 id="principe-2">Principe</h3>
<p>Ce mod√®le cherche √† construire une partition de l&rsquo;espace $\Omega^2$ dans laquelle l&rsquo;issue des combats dans chaque sous-ensemble est homog√®ne gr√¢ce √† un arbre binaire.</p>
<p>A partir de la racine qui repr√©sente l&rsquo;ensemble de d√©part, 0 √† 2 noeuds sont ajout√©s. Chaque noeud repr√©sente une <em>division</em>, c&rsquo;est-√†-dire une condition sur un attribut ou une combinaison lin√©aire d&rsquo;attributs coupant l&rsquo;ensemble en deux sous-ensemble. Cette proc√©dure est r√©p√©t√©e pour chaque sous-ensemble r√©cursivement jusqu&rsquo;√† l&rsquo;obtention des partitions homog√®nes au sens de la variable √† pr√©dire. Afin d&rsquo;avoir une s√©paration optimale √† chaque √©tape, l&rsquo;algorithme cherche la division qui optimise le crit√®re d&rsquo;<em>impuret√©</em> par une recherche √† <em>force brute</em> (it√©ration sur l&rsquo;ensemble des seuils possibles).</p>
<h3 id="r√©gularisation">R√©gularisation</h3>
<p>La capacit√© de g√©n√©ralisation d&rsquo;un arbre par rapport √† son ensemble d&rsquo;apprentissage d√©pend fortement de sa profondeur. La d√©finition d&rsquo;une <strong>profondeur maximale</strong> ou d&rsquo;un nombre de noeuds maximal permettent de limiter la croissance manuellement √† condition qu&rsquo;une division de l&rsquo;espace soit trouv√©e lors des visualisations. Sinon, un \textbf{seuil minimal de d√©croissance d&rsquo;un crit√®re} entre chaque d√©veloppement de l&rsquo;arbre peut √™tre utilis√© pour limiter la croissance en complexit√© sans perdre la pr√©cision du mod√®le.</p>
<h3 id="application-2">Application</h3>
<p>L&rsquo;analyse de l&rsquo;impact du param√®tre de croissance minimale d&rsquo;impuret√© sur la qualit√© du mod√®le de pr√©diction de la victoire √† partir des diff√©rences montre qu&rsquo;une croissance trop ralenti ($c_{min}&gt;0.4$) entra√Æne un sous-apprentissage et une croissance non contr√¥l√©e un sur-apprentissage.</p>
<p>De plus, l&rsquo;optimum global obtenu √† $c_{min} = 0.15$ est commun entre les deux crit√®res de puret√© et produit deux arbres √©quivalents de profondeur 2. La bonne qualit√© de la pr√©diction ($94.5%$ de bonne pr√©diction √† l&rsquo;issu d&rsquo;une validation crois√©e √† 5 coupes) s&rsquo;accompagne aussi de l&rsquo;interpr√©tabilit√© car le mod√®le revient √† deux conditions sur la diff√©rence de vitesse et d&rsquo;attaque entre les deux pok√©mon.</p>
<p>
<img src="/img/pokemon_tree_differences_entropy.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Arbres de d√©cision de la diff√©rences des statistiques des combats et matrice de confusion sur l&#39;√©chantillon de test de 12466 individus</p></p>
<p>La matrice de confusion r√©v√®le tout de m√™me qu&rsquo;une grande partie des erreurs de classification commises s&rsquo;explique par une sur-estimation de la capacit√© du premier pok√©mon. Ceci peut provenir d&rsquo;un l√©ger biais pour la perte du premier pok√©mon que nous allons tenter de prendre en compte dans la partie For√™t Al√©atoire.</p>
<p>De plus, l&rsquo;arbre de d√©cision produit un estimateur de variance √©lev√©e; les s√©parations sont optimis√©es localement et souvent sous-optimales, et donc chaque changement l√©ger dans les donn√©es produit des arbres compl√®tement diff√©rent.</p>
<h2 id="for√™t-al√©atoire">For√™t al√©atoire</h2>
<h3 id="principe-3">Principe</h3>
<p>La for√™t al√©atoire permet de r√©gler le probl√®me de la variance des arbres de d√©cision en regroupant plusieurs arbres en un mod√®le plus complexe.</p>
<p>L&rsquo;algorithme consiste d&rsquo;abord √† cr√©er $N$ r√©plications des donn√©es initiales $D$ par tirages avec remise, nomm√©s les √©chantillons de bootstrap $D^*_b$. On entra√Æne alors les arbres de d√©cisions $A_b$ avec les donn√©es d&rsquo;entra√Ænements $D^*_b$ par un algorithme CART l√©g√®rement modifi√©; le d√©coupage choisi correspond √† la s√©paration qui optimise le crit√®re d&rsquo;impuret√© sur un ensemble d&rsquo;attributs tir√© al√©atoirement parmi les attributs. Finalement, le classement d&rsquo;un individu se fait par vote majoritaire des arbres.</p>
<p>En moyennant les pr√©dictions d&rsquo;un groupe d&rsquo;arbre, on r√©duit la variance des arbres individuelles et en construisant des arbres sur des √©chantillons diff√©rentes et des attributs diff√©rents, on diminue le biais du mod√®le.</p>
<h3 id="application-3">Application</h3>
<p>La r√©gularisation d&rsquo;une for√™t est similaire √† celle d&rsquo;un arbre mise √† part le param√®tre du nombre d&rsquo;arbres qui constituent la for√™t. De plus, afin de r√©duire l&rsquo;effet du biais n√©gative des donn√©es, on peut attribuer d&rsquo;un poids √† chaque classe pond√®re la proportion des classes dans le calcul des crit√®res d&rsquo;impuret√©:</p>
<p>$$C_l(p) = p_l^{-}(1 - p_l^{-}) + p_l^{+}(1 - p_l^{+})$$</p>
<p>$$avec\ p_l^{-} = \frac{n_l^{-} \times w^{-}}{n_l}$$</p>
<p>Avec $C$ le crit√®re d&rsquo;impuret√©, $p^{+}<em>l$ les proportions √† un noeud $l$ des diff√©rentes classes pour les individus de l&rsquo;arbre inf√©rieur au seuil et $\omega</em>{+}$ le poids associ√© √† la classe Victoire du premier pok√©mon. Dans ce probl√®me binaire, en augmentant le poids d&rsquo;une modalit√©, on augmente son influence sur la croissance de l&rsquo;arbre et on r√©duit en m√™me temps la modalit√© inverse.</p>
<p>En associant un poids plus important √† la d√©faite, la qualit√© des pr√©dictions des arbres binaires et des for√™ts al√©atoires s&rsquo;am√©liorent de mani√®re n√©gligeable. La fluctuation de la qualit√© des pr√©dictions par rapport aux poids des classes pour l&rsquo;arbre de d√©cision peut s&rsquo;expliquer par la variance importante du mod√®le et ne peut donc pas √™tre prise en compte. M√™me en utilisant l&rsquo;option <em>balanced</em> pour les poids des classes sur sklearn et en augmentant le nombre de plis de la validation, aucune diff√©rence statistique pertinente est observable. L&rsquo;observation que nous avons fait au niveau du biais des donn√©es n&rsquo;affecte donc pas le classifieur.</p>
<p>
<img src="/img/pokemon_balance_difference.png"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Qualit√© du mod√®le de pr√©diction des taux de victoire par rapport aux poids attribu√©s √† chaque classe (sans optimisation d&#39;autres hyper-param√®tres)</p></p>
<hr>
<h2 id="adaptative-boosting">Adaptative Boosting</h2>
<h3 id="principe-4">Principe</h3>
<p>Le boosting est une m√©thode qui consiste √† construire s√©quentiellement une suite de mod√®les simples pour constituer un mod√®le plus puissant.</p>
<p>Pour un probl√®me de classification binaire d&rsquo;une variable $y$, l&rsquo;algorithme Adaboost consid√®re que les individus sont tous initialement uniform√©ment pond√©r√©s. A l&rsquo;it√©ration $i$, un nouveau mod√®le $M^i$ est construit avec le mod√®le de base sur l&rsquo;√©chantillon d&rsquo;entra√Ænement avec le poids courant des individus. Son taux d&rsquo;erreur $\varepsilon^i$ de classification est alors calcul√© puis le poids $\alpha^i$
ainsi que la pond√©ration des individus $\omega_j$ qui sera ensuite normalis√©e. L&rsquo;algorithme converge lorsque le nombre de mod√®les est satisfait ou lorsque l&rsquo;erreur est plus petite qu&rsquo;un seuil donn√©.</p>
<p>$$\varepsilon^i = \frac{\sum_{j=1}^n\omega_j\unicode{x1D7D9}(y_j \neq M^i(j))}{\sum_{j=1}^n\omega_j}$$</p>
<p>$$\alpha^i = log\left(\frac{1 - \varepsilon^i}{\varepsilon^i}\right)$$</p>
<p>$$\omega_j^{i+1} = \omega_j^{i} \times exp(\alpha^i \times \unicode{x1D7D9}(y_j \neq M^i(j)))$$</p>
<p>La mise √† jour de la pond√©ration des individus attribue un poids plus important aux individus mal classifi√©s, ce qui incite le mod√®le de boosting sur les it√©rations suivantes √† corriger les zones probl√©matiques en terme de classification. Cet avantage est √† double tranchant puisqu&rsquo;il rend le mod√®le plus sensible aux donn√©es bruit√©es ainsi qu&rsquo;√† une mauvaise classification.</p>
<p>En g√©n√©rale, Adaboost fonctionne mieux avec des mod√®les de base simples avec des puissances de pr√©diction faible comme les arbres de d√©cision.</p>
<h3 id="application-4">Application</h3>
<p>L&rsquo;application d&rsquo;Adaboost sur l&rsquo;arbre de d√©cision donne un r√©sultat similaire √† un arbre simple. Ce s&rsquo;explique par la complexit√© de l&rsquo;arbre optimal initial (de profondeur 5) ainsi que la pr√©sence des r√©sultats inattendus de certains combats (victoire d&rsquo;un pok√©mon d√©favoris√© √† l&rsquo;√©gard des statistiques de combats) auxquelles le mod√®le est plus sensible.</p>
<p>
<img src="/img/pokemon_pdp_difference.jpg"  class="center"  />


<p style="text-align:center; font-style: italic; padding-bottom: 15px;">Graphique de d√©pendance partielle des variables les plus importantes du mod√®le Adaboost de pr√©diction des combats</p></p>
<p>Le graphique de d√©pendance (repr√©sentation qui montre l&rsquo;influence d&rsquo;une ou de plusieurs variables marginales sur la pr√©diction. Pour un probl√®me de classification binaire, toute zone de probabilit√© $&gt;0.5$ correspond √† un $True$.) montre une rupture des fronti√®res de d√©cision claire qui se produit au niveau de <em>diff_speed</em> $= 0$. La d√©pendance partielle de la diff√©rence de vitesse va contre l&rsquo;intuition que la diff√©rence de vitesse influence lin√©airement la probabilit√© de victoire du pok√©mon avantag√©.</p>
<p>La forme inattendue ($1/x$) que prend la d√©pendance partielle des diff√©rence de vitesse peut s&rsquo;expliquer par la dominance des diff√©rences des taux de victoires dans le mod√®le. L&rsquo;inclusion de cette variable bruit√©e affaiblit fortement le mod√®le. Sa suppression engendre alors une am√©lioration visible du taux de pr√©diction correcte de $0.909$ √† $0.940$ et une correction de l&rsquo;√©volution de la d√©pendance partielle.</p>
<hr>
<h2 id="conclusion">Conclusion</h2>
<h3 id="√©valuation-des-performances">√âvaluation des performances</h3>
<p>Afin de comparer les performances entre diff√©rentes familles d&rsquo;algorithmes, la proc√©dure commune suivante a √©t√© suivie:</p>
<ul>
<li>Le jeu de donn√©es est divis√© en un √©chantillon d&rsquo;entra√Ænement et de test ($33%$ des donn√©es) gr√¢ce √† GridSearchCV.</li>
<li>L&rsquo;estimateur de performance choisie est l&rsquo;accuracy_score qui calcule la correspondance exacte de la pr√©diction et de la classe r√©elle par la formule:
$$\texttt{accuracy}(y, \hat{y}) = \frac{1}{n_\text{samples}} \sum_{i=0}^{n_\text{samples}-1} \unicode{x1D7D9}(\hat{y}_i = y_i)$$
Cet indicateur correspond bien √† notre cas d&rsquo;usage puisqu&rsquo;il s&rsquo;agit d&rsquo;un probl√®me de classification binaire o√π le r√©sultat d&rsquo;un combat est d√©terministe.</li>
<li>Le crit√®re de qualit√© est alors calcul√© par validation crois√©e √† cinq coupes afin de r√©duire le biais et optimis√© sur l&rsquo;espace d&rsquo;hyper-param√®tre correspondant.</li>
</ul>
<table>
<thead>
<tr>
<th align="center">Mod√®les</th>
<th align="center">Accuracy score</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">KNN</td>
<td align="center">0.92</td>
</tr>
<tr>
<td align="center">SVM</td>
<td align="center">0.9273</td>
</tr>
<tr>
<td align="center">Arbre de d√©cision</td>
<td align="center">0.945</td>
</tr>
<tr>
<td align="center">For√™t al√©atoire</td>
<td align="center">0.949</td>
</tr>
<tr>
<td align="center">AdaBoost d‚Äôarbre</td>
<td align="center">0.940</td>
</tr>
</tbody>
</table>
<p>M√™me avec une √©valuation pessimiste de la qualit√©, les mod√®les construits peuvent tous r√©pondre ad√©quatement √† notre probl√©matique.</p>
<p>Afin de minimiser le temps d&rsquo;entra√Ænement, d&rsquo;optimiser la qualit√© du mod√®le et de maintenir l&rsquo;interpr√©tabilit√©, l&rsquo;arbre de d√©cision correspond au choix optimal pour notre jeu de donn√©es synth√©tiques. On peut alors √©mettre l&rsquo;hypoth√®se suivante sur la g√©n√©ration des donn√©es : la victoire est g√©n√©r√©e selon deux conditions sur la diff√©rence de vitesse et d&rsquo;attaque entre les deux pok√©mons puis du bruit al√©atoire introduit pour complexifier la classification.</p>
<h3 id="conclusions-et-futurs-travaux">Conclusions et futurs travaux</h3>
<p>Ce projet nous a permis d&rsquo;appliquer et de comprendre les algorithmes de classification vus en cours sur un jeu de donn√©es &ldquo;r√©elles&rdquo; et d&rsquo;explorer d&rsquo;autres mod√®les comme les SVM ou l&rsquo;Adaboost. Il nous a aussi fait comprendre l&rsquo;importance de l&rsquo;analyse pr√©liminaire et du nettoyage dans la construction d&rsquo;un mod√®le d&rsquo;apprentissage automatique.</p>
<p>Pour aller plus loin, on peut √©tudier d&rsquo;autres algorithmes comme la r√©gression logistique ou les analyses discriminantes. De plus, on peut identifier et √©tudier les zones probl√©matiques pour chaque classifieur et d√©terminer si certains attributs suivent une distribution particuli√®re dans ces zones. Puis dans un deuxi√®me temps, scinder le jeu de donn√©es en partie probl√©matique et non probl√©matique puis appliquer des mod√®les diff√©rentes √† chaque partie. Enfin, afin d&rsquo;obtenir un jeu de donn√©es plus repr√©sentatif du jeu Pok√©mon, peut-√™tre que r√©cup√©rer les r√©sultats de combats r√©ellement jou√©s par des joueurs serait pertinent. Des applications comme &ldquo;Pok√©mon Showdown&rdquo; le permettent.</p>

            </div>
        </article>
        <h2 id="end"></h2>
        <hr />

        <div class="post-info">
  				<p>
  					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://ichbinfrog.github.io/tags/ml">ml</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/pokemon">pokemon</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/svm">svm</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/knn">knn</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/decision-tree">decision tree</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/random-forest">random forest</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/adaboost">adaboost</a></span>
  				</p>
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2022</span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span><a href="https://themes.gohugo.io/hugo-theme-hello-friend-ng/">hello-friend-ng</a> Theme for <a href="http://gohugo.io">Hugo</a> by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.dc716e9092c9820b77f96da294d0120aeeb189b5bcea9752309ebea27fd53bbe6b13cffb2aca8ecf32525647ceb7001f76091de4199ac5a3caa432c070247f5b.js" integrity="sha512-3HFukJLJggt3&#43;W2ilNASCu6xibW86pdSMJ6&#43;on/VO75rE8/7KsqOzzJSVkfOtwAfdgkd5BmaxaPKpDLAcCR/Ww=="></script>



    </body>
</html>
