<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Ce travail a été fait avec Marc DAMIE dans le cadre de l&amp;rsquo;UV IA02
 Représentation d&amp;rsquo;une grille Nous avons décidé de représenter une grille comme étant une &amp;ldquo;matrice&amp;rdquo;, c&amp;rsquo;est-à-dire une liste avec neuf listes imbriquées avec neuf éléments dans chaque liste. Pour la représentation d&amp;rsquo;une cellule vide, nous avons décidé d&amp;rsquo;utiliser une variable anonyme _ , la variable anonyme, elle, peut s&amp;rsquo;unifier avec tout caractère et donc avec 0 (propriété que l&amp;rsquo;on utilisera pour le programme qui suit)." />
<meta name="keywords" content=", prolog, sudoku" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://ichbinfrog.github.io/projects/sudoku/" />
<script type="text/javascript" async
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$']],
            processEscapes: true,
            processEnvironments: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            TeX: {
                equationNumbers: { autoNumber: "AMS" },
                extensions: ["AMSmath.js", "AMSsymbols.js"]
            }
        }
    });
    MathJax.Hub.Queue(function () {
        
        
        
        var all = MathJax.Hub.getAllJax(), i;
        for (i = 0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });

    MathJax.Hub.Config({
        
        TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
</script>


    <title>
        
            [ FR ] — Prolog sudoku solver :: Hoang Quoc Trung 
        
    </title>



<link href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.2.1/css/flag-icon.min.css" rel="stylesheet"
    type="text/css">



<link rel="stylesheet" href="/main.min.753fac8f03736f0edc9be411eb20cee875dd7bb8e73c8155fbf6a629c863f4ca.css">


    
        <link rel="stylesheet" type="text/css" href="/css/post.css">
    





<meta itemprop="name" content="[ FR ] — Prolog sudoku solver">
<meta itemprop="description" content="Ce travail a été fait avec Marc DAMIE dans le cadre de l&rsquo;UV IA02
 Représentation d&rsquo;une grille Nous avons décidé de représenter une grille comme étant une &ldquo;matrice&rdquo;, c&rsquo;est-à-dire une liste avec neuf listes imbriquées avec neuf éléments dans chaque liste. Pour la représentation d&rsquo;une cellule vide, nous avons décidé d&rsquo;utiliser une variable anonyme _ , la variable anonyme, elle, peut s&rsquo;unifier avec tout caractère et donc avec 0 (propriété que l&rsquo;on utilisera pour le programme qui suit).">
<meta itemprop="datePublished" content="2018-12-21T16:12:56&#43;02:00" />
<meta itemprop="dateModified" content="2018-12-21T16:12:56&#43;02:00" />
<meta itemprop="wordCount" content="1240">
<meta itemprop="image" content="https://ichbinfrog.github.io/"/>



<meta itemprop="keywords" content="prolog,sudoku," />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ichbinfrog.github.io/"/>

<meta name="twitter:title" content="[ FR ] — Prolog sudoku solver"/>
<meta name="twitter:description" content="Ce travail a été fait avec Marc DAMIE dans le cadre de l&rsquo;UV IA02
 Représentation d&rsquo;une grille Nous avons décidé de représenter une grille comme étant une &ldquo;matrice&rdquo;, c&rsquo;est-à-dire une liste avec neuf listes imbriquées avec neuf éléments dans chaque liste. Pour la représentation d&rsquo;une cellule vide, nous avons décidé d&rsquo;utiliser une variable anonyme _ , la variable anonyme, elle, peut s&rsquo;unifier avec tout caractère et donc avec 0 (propriété que l&rsquo;on utilisera pour le programme qui suit)."/>



    <meta property="og:title" content="[ FR ] — Prolog sudoku solver" />
<meta property="og:description" content="Ce travail a été fait avec Marc DAMIE dans le cadre de l&rsquo;UV IA02
 Représentation d&rsquo;une grille Nous avons décidé de représenter une grille comme étant une &ldquo;matrice&rdquo;, c&rsquo;est-à-dire une liste avec neuf listes imbriquées avec neuf éléments dans chaque liste. Pour la représentation d&rsquo;une cellule vide, nous avons décidé d&rsquo;utiliser une variable anonyme _ , la variable anonyme, elle, peut s&rsquo;unifier avec tout caractère et donc avec 0 (propriété que l&rsquo;on utilisera pour le programme qui suit)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ichbinfrog.github.io/projects/sudoku/" />
<meta property="og:image" content="https://ichbinfrog.github.io/"/>
<meta property="article:published_time" content="2018-12-21T16:12:56+02:00" />
<meta property="article:modified_time" content="2018-12-21T16:12:56+02:00" /><meta property="og:site_name" content="Hoang Quoc Trung" />






    <meta property="article:published_time" content="2018-12-21 16:12:56 &#43;0200 &#43;0200" />








    </head>

    <body class="">
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text">ichbinfrog</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu" style="border-right:none">
    <ul class="menu__inner"><li><a href="https://ichbinfrog.github.io/about">About</a></li><li><a href="https://ichbinfrog.github.io/projects">Projects</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
            <span class="theme-toggle unselectable"><svg class="theme-toggler" width="24" height="24" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
  <path d="M22 41C32.4934 41 41 32.4934 41 22C41 11.5066 32.4934 3 22
  3C11.5066 3 3 11.5066 3 22C3 32.4934 11.5066 41 22 41ZM7 22C7
  13.7157 13.7157 7 22 7V37C13.7157 37 7 30.2843 7 22Z"/>
</svg>
</span>
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title" id="top"><a href="https://ichbinfrog.github.io/projects/sudoku/">[ FR ] — Prolog sudoku solver</a></h2>
            <aside id="toc"><style>
.toc {
    position: fixed;
    top: 50%;
    left: 2%;
    width: 20%;
    transform: translateY(-50%);
    border-radius: 5px;
    padding-bottom: 1rem;
}

.toc a {
    text-decoration: none;
    color: gray;
}

.toc a:hover {
    opacity: 0.5;
}

.toc ul {
    list-style: ">  ";
}

.toc-title {
    text-decoration: underline;
}
</style>

<div class="toc">
    <div class="toc-title">Table of Contents</div>
    <nav id="TableOfContents">
  <ul>
    <li><a href="#représentation-dune-grille">Représentation d&rsquo;une grille</a>
      <ul>
        <li><a href="#inconvénients">Inconvénients</a></li>
        <li><a href="#avantages">Avantages</a></li>
        <li><a href="#manipulation-de-la-matrice">Manipulation de la matrice</a></li>
      </ul>
    </li>
    <li><a href="#recherche-dune-solution">Recherche d&rsquo;une solution</a>
      <ul>
        <li><a href="#génération-dune-valeur-valide-pour-une-case-donnée">Génération d&rsquo;une valeur valide pour une case donnée</a></li>
        <li><a href="#génération-dune-ligne-valide">Génération d&rsquo;une ligne valide</a></li>
        <li><a href="#génération-dune-solution">Génération d&rsquo;une solution</a></li>
      </ul>
    </li>
    <li><a href="#génération-avec-gradient-de-difficultés">Génération avec gradient de difficultés</a>
      <ul>
        <li><a href="#digging-hole">Digging hole</a></li>
        <li><a href="#propagation">Propagation</a></li>
      </ul>
    </li>
    <li><a href="#améliorations-possibles">Améliorations possibles</a>
      <ul>
        <li><a href="#linterface">L&rsquo;interface</a></li>
        <li><a href="#la-difficulté">La difficulté</a></li>
      </ul>
    </li>
  </ul>
</nav>
    <ul>
    <li><a href="#top">Top</a></li>
    <li><a href="#end">End</a></li>
    </ul>
</div></aside>

            

            <div class="post-content">
                <blockquote>
<p>Ce travail a été fait avec Marc DAMIE dans le cadre de l&rsquo;UV IA02</p>
</blockquote>
<h2 id="représentation-dune-grille">Représentation d&rsquo;une grille</h2>

<img src="/img/sudoku_representation.png"  class="center"  />


<p>Nous avons décidé de représenter une grille comme étant une &ldquo;matrice&rdquo;, c&rsquo;est-à-dire une liste avec neuf listes imbriquées avec neuf éléments dans chaque liste. Pour la représentation d&rsquo;une cellule vide, nous avons décidé d&rsquo;utiliser une variable anonyme _ , la variable anonyme, elle, peut s&rsquo;unifier avec tout caractère et donc avec 0 (propriété que l&rsquo;on utilisera pour le programme qui suit). Avec cette structure, nous en tirons les avantages et les inconvénients suivants:</p>
<h3 id="inconvénients">Inconvénients</h3>
<p>Avec cette structure, insérer une valeur dans une cellule nécessite un temps de calcul plus important vu que l&rsquo;on doit parcourir récursivement l&rsquo;ensemble de la liste (ce qui, dans le pire des cas, engendrait 81 opérations). A ceci, se rajoute le fait que l&rsquo;accès à une certaine colonne n&rsquo;est pas directe, ce qui va réduire l&rsquo;efficacité des tests au cours de la génération de la grille (notamment celui de l&rsquo;unicité sur une colonne). Finalement, sa performance n&rsquo;est pas optimale pour les grilles presque vides, vu qu&rsquo;elle associe à chaque case vide une valeur 0 et peut-être une question sur l&rsquo;optimisation de l&rsquo;espace mémoire utilisée.</p>
<h3 id="avantages">Avantages</h3>
<p>Elle demeurent, néanmoins, plus adaptée que la représentation d&rsquo;une grille par une base de faits dynamiques (ex; prédicat board(I,J,Val) représentant qu&rsquo;à la i-ème ligne, j-ème colonne, il y a la valeur Val) car elle permet facilement de tester la validité d&rsquo;une insertion (le backtracking sur les assertions dynamiques étant presque impossible). Contrairement à la vérification de la validité des colonnes, l&rsquo;unicité des lignes et des carrées 3x3 peuvent être vérifiées assez rapidement avec cette matrice. La représentation matricielle, elle, simplifie aussi les opérations de propagation (cf Génération de grille) telles que les rotations, les permutations de grilles.</p>
<h3 id="manipulation-de-la-matrice">Manipulation de la matrice</h3>
<p>Pour manipuler cette structure, nous avons appuyé notre code sur le prédicat element(I,J,B,X). Celui-ci nous permettra d&rsquo;obtenir l&rsquo;élément à la position I,J. Il offre une certaine optimisation car on peut obtenir n&rsquo;importe quel élément en maximum 18 opérations: n a besoin de 9 opérations pour atteindre la 9ième ligne et 9 autres pour atteindre le 9ième élément de celle-ci.</p>
<h2 id="recherche-dune-solution">Recherche d&rsquo;une solution</h2>
<h3 id="génération-dune-valeur-valide-pour-une-case-donnée">Génération d&rsquo;une valeur valide pour une case donnée</h3>
<p>La brique de base de notre résolution est de générer pour une case donnée une valeur valide pour la ligne, la colonne et le carré. Par valeur valide, on entend une valeur unique sur la ligne, la colonne et le carré. On utilise alors trois prédicats qu&rsquo;on unifiera: un prédicat propose les nombres absents de la ligne, un autre les nombre absents de la colonne et un dernier les nombres absents du carré. Ainsi, pour obtenir une valeur valide pour la case, on unifie les trois.</p>
<p>Notons dès maintenant qu&rsquo;ajouter une valeur valide ne garantit pas que cela mènera à une solution. En effet, il existe des grilles valides mais sans solution.</p>
<h3 id="génération-dune-ligne-valide">Génération d&rsquo;une ligne valide</h3>
<p>La seconde étape est de générer une ligne valide, c&rsquo;est-à-dire une ligne remplie de valeurs valides. Elles sont donc différentes de chacune des autres valeurs de leurs colonnes et carrés respectifs. Cette génération se fait de manière récursive: pour la position I, on récupère la liste ayant les indices supérieurs à I remplis avec de valeurs valides. On génère ensuite une valeur valide pour la position I dans cette liste ayant été obtenue récursivement. En faisant un appel avec l&rsquo;indice 1, on obtient donc une liste résultat contenant uniquement des valeurs uniques. Dans cette génération on ne supprime évidemment pas les valeurs déjà présentes dans la liste.</p>
<h3 id="génération-dune-solution">Génération d&rsquo;une solution</h3>
<p>L&rsquo;étape finale est un peu semblable à l&rsquo;étape précédente mais à une échelle supérieure. On utilise un prédicat récursif: pour la ligne I, on récupère récursivement un board rempli avec des lignes valides aux indices supérieurs à I. On insère donc une ligne valide à la position I.La ligne I devra donc être valide par rapport au tableau de départ complété par les valeurs valides générées précédemment. Si pour une ligne I, il n&rsquo;existe pas de ligne valide, le programme va faire un retour arrière et changer les lignes précédemment générées.</p>
<h2 id="génération-avec-gradient-de-difficultés">Génération avec gradient de difficultés</h2>
<p>Tout d&rsquo;abord on utilise produit une grille valide remplie avec une dizaine de valeurs aléatoires. ensuite on utilise notre algorithme de résolution pour obtenir une solution de la grille à laquelle on va supprimer des cellules pour que l&rsquo;utilisateur puisse jouer. On a rempli partiellement la grille de manière aléatoire pour obtenir à chaque partie de nouvelles grilles. En effet, le résolveur résoudra toujours de la même manière une grille vide donc on aura un manque de diversité dans les grilles produites. La difficulté d&rsquo;un sudoku provient de trois facteurs majeurs;</p>
<ul>
<li>le nombre de cellules initiales données au joueur</li>
</ul>

<img src="/img/sudoku_cells.png"  class="center"  />


<ul>
<li>le choix de l&rsquo;algorithme de &ldquo;digging hole&rdquo; (c&rsquo;est-à-dire de parcours de la grille et de vérifications des cellules candidates pour supprimer)</li>
<li>l&rsquo;application des propagations équivalentes telles que les rotations, les permutations des colonnes (1 par 1 ou 3 par 3).</li>
</ul>
<h3 id="digging-hole">Digging hole</h3>
<p>On distingue dès lors quatre type de séquences d&rsquo;établissement des digging holes;</p>
<ul>
<li>Left to Right Then To Bottom</li>
<li>Wandering along S</li>
<li>Jumping One Cell</li>
<li>Randomizing globally</li>
</ul>

<img src="/img/sudoku_dig.png"  class="center"  />


<p>Dans notre algorithme, nous avons implémenter, par faute de temps, que deux types de séquences. Pour les difficultés faciles et extremement faciles, nous utilisons une séquence Randomized Globally, c&rsquo;est-à-dire que l&rsquo;on génère aléatoirement un couple (I,J) puis on vérifie si la suppression de cette cellule maintient l&rsquo;unicité de la solution. Pour les difficultés moyennes et difficiles, nous obtenons la grille en supprimant les cellules obtenues par Jumping One Cell (on génère d&rsquo;abord un couple puis on le fait déplacer selon des directions aléatoires). Avec cette algorithme de déplacement de la cellule à supprimer, il est possible que l&rsquo;on rencontre un échec où toutes les cellules adjacentes sont déjà supprimées. Dans ce cas, il va falloir relancer la suppression sur une cellule aléatoire.</p>
<h3 id="propagation">Propagation</h3>
<p>Pour les sudoku de difficultés importantes, il est nécessaire que les symétries, ou les motifs ne soient pas visibles au joueur. Dès lors, on doit appliquer des algorithmes qui permettent, à partir d&rsquo;une grille valide remplie, d&rsquo;en générer une autre sans trop de calculs complémentaires. Ces algorithmes, nommés des algorithmes de propagation telles que la rotation de la matrice, l&rsquo;échange des colonnes permettent masquer ses motifs, tout en préservant l&rsquo;ensemble des propriétés d&rsquo;un sudoku valide. Nous avons implémentés ces permutations pour les jeux &ldquo;medium&rdquo; et &ldquo;hard&rdquo;.</p>

<img src="/img/sudoku_permutation.png"  class="center"  />


<h2 id="améliorations-possibles">Améliorations possibles</h2>
<h3 id="linterface">L&rsquo;interface</h3>
<p>D&rsquo;une part, jouer dans la console n&rsquo;est pas très pratique, particulièrement pour le sudoku. Il serait donc intéressant de générer une fenêtre.
D&rsquo;autre part, nous n&rsquo;avons pas réussi à créer une boucle de génération de solutions illimitée. En effet, notre boucle aura un nombre précis d&rsquo;itérations. Nous n&rsquo;avons pas réussi à faire une boucle qui s&rsquo;arrête soit si le joueur le souhaite, soit si il n&rsquo;y a plus de solutions.
De plus, on pourrait faire un mode qui guide un joueur débutant dans la résolution d&rsquo;une première grille (une sorte de tutoriel).</p>
<h3 id="la-difficulté">La difficulté</h3>
<p>Nous avons essayé de nous approprier rapidement l&rsquo;article mais on se rend bien compte qu&rsquo;il existe des cas où là génération de grilles ne fournit pas forcément une grille du niveau souhaité (ceci est surtout vrai pour les grilles de difficultés moyenne et difficile). On pourrait donc relire cette article et retravailler notre code. De plus, avec un peu plus de temps, on pourrait le confronter avec d&rsquo;autres articles de la littérature traitant du sudoku (de manière académique).</p>

            </div>
        </article>
        <h2 id="end"></h2>
        <hr />

        <div class="post-info">
  				<p>
  					<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg><span class="tag"><a href="https://ichbinfrog.github.io/tags/prolog">prolog</a></span><span class="tag"><a href="https://ichbinfrog.github.io/tags/sudoku">sudoku</a></span>
  				</p>
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    <div class="footer__inner">
        <div class="footer__content">
            <span>&copy; 2020</span>
            
            <span><a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0</a></span>
        </div>
    </div>
    <div class="footer__inner">
        <div class="footer__content">
            <span><a href="https://themes.gohugo.io/hugo-theme-hello-friend-ng/">hello-friend-ng</a> Theme for <a href="http://gohugo.io">Hugo</a> by <a href="https://github.com/rhazdon">Djordje Atlialp</a></span>
        </div>
    </div>
</footer>

            
        </div>

        




<script type="text/javascript" src="/bundle.min.4a69500057d68129e88f497d354afe68422eb56de6d15e45dbe2190858ea5a76bfcb096406f992984b241db45f47388ac57ab0376e3b32125bef7a8a6d0f06c4.js" integrity="sha512-SmlQAFfWgSnoj0l9NUr&#43;aEIutW3m0V5F2&#43;IZCFjqWna/ywlkBvmSmEskHbRfRziKxXqwN247MhJb73qKbQ8GxA=="></script>



    </body>
</html>
